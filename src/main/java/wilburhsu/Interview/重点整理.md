自我介绍

面试官您好，我叫徐维波，2017年毕业于重庆大学计算机学院，之后加入长江证券信息总部，从事Java后台开发工作，目前已经有三年的Java开发经验。在长江证券工作期间，我作为核心开发人员参与了长江e号高端资讯、长江证券AppServer总线项目、长江证券运维监控基础平台等几个项目的设计、开发和维护工作。关于我考虑换工作的原因，是因为目前的工作属于金融行业，我个人更希望能进入互联网行业发展。



### 1.Java集合

#### ArrayList、LinkedList

ArrayList：数组实现，自动扩容1.5倍

LinkedList：双向链表实现，带有头结点和尾结点，头插和尾插性能好

#### HashMap

put方法过程：

0. 判断是否需要扩容

1. key值计算hash，得到32位hashcode

2. 将得到的hashcode右移16位取得高16位
3. 将前两步得到的值进行异或运算得到最终的hash值
4. 然后根据数组长度进行取模计算， `(n - 1) & hash` ，得到在数组中的 index 下标
5. 索引位置为空，建立新的k-v节点；如果不为空，先判断已存在的key值的hash与要插入的是否相同，相同覆盖，不相同以链表形式连接到当前key值之后

#### ConcurrentHashMap

分段锁

### 2.并发

#### volatile

作用：防止指令重排序，保障可见性，不保证原子性

底层原理：内存屏障

#### synchronized

底层原理：同步语句块使用monitor.enter和monitor.exit指令，同步方法使用ACC_SYNCHRONIZED 标识

#### 线程池工作原理

`ThreadPoolExecutor`执行`execute()`方法分4步：

1. 如果当前运行的线程少于`corePoolSize`，则创建新线程来执行任务（需要获取全局锁）
2. 如果运行的线程等于或多于`corePoolSize`，则将任务加入`BlockingQueue`
3. 如果无法将任务加入`BlockingQueue`（队列已满），则创建新的线程来处理任务（需要获取全局锁）
4. 如果创建新线程将使当前运行的线程超出`maximumPoolSize`，任务将被拒绝，并调用`RejectedExecutionHandler.rejectedExecution()`方法

`ThreadPoolExecutor`采取上述步骤的总体设计思路，是为了在执行`execute()`方法时，尽可能地避免获取全局锁（那将会是一个严重的可伸缩瓶颈）。在`ThreadPoolExecutor`完成预热之后（当前运行的线程数大于等于`corePoolSize`），几乎所有的`execute()`方法调用都是执行步骤2，而步骤2不需要获取全局锁

线程池处理流程图：

![image](https://note.youdao.com/yws/public/resource/aba0f08fcb448be8bda00fbd1ddd049d/xmlnote/1938A70E46EA414AB7B7244FB2267EA1/5547)

#### CyclicBarrrier和CountdownLatch



#### ReadWriteLock及AQS



### 3.NIO

SelectorKey

Channel

### 4.JVM

#### 内存模型

线程共享和线程私有

#### 垃圾回收策略

引用计数，可达性分析算法

#### 垃圾回收算法

标记-清除算法，复制算法，标记-整理算法

#### 类加载机制

#### GC调优

GC调优一般具体是通过GC日志的情况来分析。

1. 发现minor gc频繁，新生代空间太小了。
2. 如果发现晋升的年龄很小，老年代迅速被填满，导致频繁的major gc，并且回收比率又很大，那说明对象的生命周期确实很短也需要调整新生代。
3. 如果看full gc很频繁，但是每次回收的内存就一点点，那目测就是内存泄露了。

总体上就是根据分代的根本，也就是新生代朝生夕死的事实调整GC，避免分配大对象。具体还是得分析GC日志

### 5.框架

#### Spring

IoC、AOP，动态代理，Spring Bean生命周期

### 6.数据库（MySQL）

#### 事务

1. 事务特性

2. 隔离级别

   读未提交，读已提交，可重复读，串行化

3. MVCC

#### 索引

#### 锁

共享锁，排它锁，意向共享锁，意向排它锁

解决死锁：超时机制，等待图（锁的信息链表，事务等待链表）

#### 日志



### 7.消息队列Kafka



### 8.缓存Redis

#### 线程模型



#### 五个对象及底层数据结构

字符串



列表



哈希对象



集合对象



有序集合对象



#### 过期删除机制，淘汰机制



#### 持久化



#### 主从



#### 哨兵



#### 集群



#### 事务



#### 一致性哈希



#### 缓存雪崩

- 事前：Redis 高可用，主从+哨兵，Redis cluster，避免全盘崩溃。
- 事中：本地 ehcache 缓存 + hystrix 限流&降级，避免 MySQL 被打死。
- 事后：Redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。

#### 缓存穿透

每次系统 A 从数据库中只要没查到，就写一个空值到缓存里去，比如 `set -999 UNKNOWN` 。然后设置一个过期时间，这样的话，下次有相同的 key 来访问的时候，在缓存失效之前，都可以直接从缓存中取数据。

#### 缓存击穿

- 若缓存的数据是基本不会发生更新的，则可尝试将该热点数据设置为永不过期。
- 若缓存的数据更新不频繁，且缓存刷新的整个流程耗时较少的情况下，则可以采用基于 Redis、zookeeper 等分布式中间件的分布式互斥锁，或者本地互斥锁以保证仅少量的请求能请求数据库并重新构建缓存，其余线程则在锁释放后能访问到新缓存。
- 若缓存的数据更新频繁或者在缓存刷新的流程耗时较长的情况下，可以利用定时线程在缓存过期前**主动地重新构建缓存或者延后缓存的过期时间**，以保证所有的请求能一直访问到对应的缓存。

#### 缓存并发竞争

解释：多个客户端写一个 key，如果顺序错了，数据就不对了。但是顺序我们无法控制。

解决方案：使用分布式锁，例如 zk，同时加入数据的时间戳。同一时刻，只有抢到锁的客户端才能写入，同时，写入时，比较当前数据的时间戳和缓存中数据的时间戳。

#### 数据库和缓存双写一致性

- 读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。
- 更新的时候，**先更新数据库，然后再删除缓存**。

### 9.RPC框架Dubbo



### 10.实时计算Flink



### 11.数据结构与算法

