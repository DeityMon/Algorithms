自我介绍

面试官您好，我叫徐维波，2017年毕业于重庆大学计算机学院，之后加入长江证券信息总部，从事Java后台开发工作，目前已经有三年的Java开发经验。在长江证券工作期间，我作为核心开发人员参与了长江e号高端资讯、长江证券AppServer总线项目、长江证券运维监控基础平台等几个项目的设计、开发和维护工作，目前是长江e家App后台项目的负责人。关于我考虑换工作的原因，是因为目前的工作属于金融行业，我个人更希望能进入互联网行业发展。



## 1.Java集合

### ArrayList、LinkedList

ArrayList：数组实现，自动扩容1.5倍

LinkedList：双向链表实现，带有头结点和尾结点，头插和尾插性能好

### HashMap

put方法过程：

0. 判断是否需要扩容

1. key值计算hash，得到32位hashcode

2. 将得到的hashcode右移16位取得高16位
3. 将前两步得到的值进行异或运算得到最终的hash值
4. 然后根据数组长度进行取模计算， `(n - 1) & hash` ，得到在数组中的 index 下标
5. 索引位置为空，建立新的k-v节点；如果不为空，先判断已存在的key值的hash与要插入的是否相同，相同覆盖，不相同以**链表**形式连接到当前key值之后

### ConcurrentHashMap

分段锁

## 2.并发

并发编程的3个基本特性：原子性，可见性，有序性。

### volatile关键字

**作用：**

`volatile`是轻量级的`synchronized`，保障可见性、保障有序性和保障long/double类型变量读写操作的原子性

1. 保障原子性：保障long/double类型变量读写操作的原子性（Java对除long和double之外的基本类型的写操作都是原子性的，但是32位虚拟机上对这两种变量的写操作不具备原子性，要保证原子性需要用volatile进行修饰）

2. 保障有序性：提示JIT编译器被修饰的变量可能被多个线程共享，以阻止JIT编译器做出可能导致程序运行不正常的优化

3. 保障可见性：

   1. 读取一个volatile关键字修饰的变量会使相应的处理器执行**刷新处理器缓存**（从其他处理器的高速缓存或者主内存中对更新的共享变量进行缓存同步）的动作
   2. 写一个volatile关键字修饰的变量会使相应的处理器执行**冲刷处理器缓存**（将对共享变量的更新从写缓冲器写入到高速缓存或者主内存中）的工作

   两者结合保障了可见性。

**应用场景：**

1. 使用`volatile`变量作为状态标志
2. 使用`volatile`保证可见性
3. 在有限的一些情形下使用`volatile`变量替代锁
4. 使用`volatile`实现简易版读写锁（混合使用锁和volatile变量，锁保障原子性，volatile保障可见性）

**底层原理：**

`volatile` 的底层实现原理是内存屏障，内存屏障提供3个功能：

1. 确保指令重排序时不会把内存屏障前后的指令交换顺序，在执行到内存屏障这句指令时，它前面的操作已经全部完成
2. 它会强制将对缓存的修改操作立即写入主存；
3. 如果是写操作，它会导致其他CPU中对应的缓存行无效

可见性的实现：

1. 对 `volatile` 变量的写指令后会加入写屏障，写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中 
2. 对 `volatile` 变量的读指令前会加入读屏障 ，读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据  

有序性的实现：

1. 写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后
2. 读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前 

更底层是读写变量时使用 lock 指令来保证多核 CPU 之间的可见性与有序性  

### synchronized关键字

 `synchronized` 关键字，有以下三种使用方式:

- **同步普通方法**，锁的是当前对象。
- **同步静态方法**，锁的是当前 `Class` 对象。
- **同步块**，锁的是 `()` 中的对象。

实现原理： `JVM` 通过进入、退出对象监视器( `Monitor` )来实现对方法、同步块的同步。

1. synchronized 同步语句块的情况

   synchronized 同步语句块的实现使用的是 monitor.enter 和 monitor.exit 指令。

   monitor.enter 指令指向同步代码块的开始位置，monitor.exit 指令则指明同步代码块的结束位置。本质就是对一个对象监视器( `Monitor` )进行获取，而这个获取过程具有排他性从而达到了同一时刻只能一个线程访问的目的。

   执行 monitor.enter 指令时，线程试图获取锁也就是获取 monitor（monitor对象存在于每个Java对象的对象头中）的持有权。

   当计数器为0则可以成功获取，获取后将锁计数器加1。在执行 monitorexit 指令后，将锁计数器设为0，表明锁被释放

2. synchronized 修饰方法的的情况

   JVM 通过访问ACC_SYNCHRONIZED 方法标识符来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。

### Java中的锁

1. `synchronized`关键字

2. `java.util.concurrent.locks`包下常用的类

   1. `Lock`接口

      `ReentrantLock`：可重入锁，`Lock`接口的一个实现，继承AQS，并且提供了更多的方法

   2. `ReadWriteLock`接口

      `ReentrantReadWriteLock`：可重入的读写锁，实现了`ReadWriteLock`接口，最主要的有两个方法：`readLock()`和`writeLock()`用来获取读锁和写锁

   3. `StampedLock`：JDK8新增

### AQS

AQS全称是 AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架。

原理：用volatile修饰共享变量state，线程通过对state的CAS操作来获取锁和解锁，成功则获取锁成功，失败则park相关线程之后进入等待队列或条件等待队等待，有公平和非公平两种模式来唤醒等待的线程。使用AQS是为了封装和抽象，通过封装公共的方法，减少代码重复。

AQS 的基本思想如下：

获取锁的逻辑

```
while(state 状态不允许获取) {
	if(队列中还没有此线程) {
		入队并阻塞
	}
}
当前线程出队
```

释放锁的逻辑

```
if(state 状态允许了) {
	恢复阻塞的线程(s)
}
```

### volatile和synchronized区别

- `volatile`关键字是线程同步的轻量级实现，`volatile`不具有排他性，也不会导致上下文切换，所以`volatile`性能比`synchronized`关键字要好
- 但是`volatile`关键字只能用于变量，而`synchronized`关键字可以修饰方法以及代码块
- 多线程访问`volatile`关键字不会发生阻塞，而`synchronized`关键字可能会发生阻塞
- `volatile`关键字能保证数据的可见性，但不能保证数据的原子性。`synchronized`关键字两者都能保证
- `volatile`关键字主要用于解决变量在多个线程之间的可见性，而`synchronized`关键字解决的是多个线程之间访问资源的同步性

### synchronized和lock区别

1.  两者都是可重入锁
   - 都是加锁方式同步，而且都是阻塞式的同步
   - 两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。同一个线程每次获取锁，锁的计数器都自增1，要等到锁的计数器下降为0时才能释放锁。

2.  `synchronized` 依赖于 JVM 而 `ReentrantLock` 依赖于 API
   - `synchronized`是java语言的关键字，是原生语法层面的互斥，是依赖于 JVM 实现的
   - `ReentrantLock` 是 JDK 层面实现的，需要 `lock() `和` unlock() `方法配合` try`/`finally` 语句块来完成

3. 在锁的细粒度和灵活度和方面，`ReentrantLock`优于`synchronized`
   - `synchronized`由编译器去保证锁的加锁和释放
   - `ReenTrantLock`需要手工声明来加锁和释放锁

4. `ReentrantLock` 比 `synchronized` 增加了一些高级功能
   - `ReentrantLock`通过`lock.lockInterruptibly()`提供了一种能够中断等待锁的线程的机制
   - `ReentrantLock`可以指定是公平锁还是非公平锁，`synchronized`只能是非公平锁。通过 `ReentrantLock`类的`ReentrantLock(boolean fair)`构造方法来指定
   - 等待/通知机制：`synchronized`关键字与`wait()`和`notify()`/`notifyAll()`方法相结合实现，`ReentrantLock`类借助于`Condition`接口与`newCondition() `方法实现

### 线程池

#### 线程池参数

```java
new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, milliseconds,runnableTaskQueue, handler);
```

1. `corePoolSize`：线程池的基本大小。当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程。如果调用了线程池的`prestartAllCoreThreads()`方法，线程池会提前创建并启动所有基本线程
2. `maximumPoolSize`：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。使用无界队列此参数无效。
3. `keepAliveTime`：空闲线程存活时间。一个线程如果处于空闲状态，并且当前的线程数量大于corePoolSize，那么在keepAliveTime时间后，空闲线程会被销毁。
4. `milliseconds`：`TimeUnit`枚举类型的值，代表`keepAliveTime`时间单位
5. `runnableTaskQueue`：任务队列。用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列
   - `ArrayBlockingQueue`：基于数组结构的有界阻塞队列
   - `LinkedBlockingQueue`：基于链表结构的阻塞队列。
   - `SynchronousQueue`：不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态
   - `PriorityBlockingQueue`：具有优先级的无限阻塞队列

6. `RejectedExecutionHandler`：拒绝策略。

#### 线程池原理

`ThreadPoolExecutor`执行`execute()`方法分4步：

1. 如果当前运行的线程少于`corePoolSize`，则创建新线程来执行任务（需要获取全局锁）
2. 如果运行的线程等于或多于`corePoolSize`，则将任务加入`BlockingQueue`
3. 如果无法将任务加入`BlockingQueue`（队列已满），则创建新的线程来处理任务（需要获取全局锁）
4. 如果创建新线程将使当前运行的线程超出`maximumPoolSize`，任务将被拒绝，并调用`RejectedExecutionHandler.rejectedExecution()`方法

`ThreadPoolExecutor`采取上述步骤的总体设计思路，是为了在执行`execute()`方法时，尽可能地避免获取全局锁（那将会是一个严重的可伸缩瓶颈）。在`ThreadPoolExecutor`完成预热之后（当前运行的线程数大于等于`corePoolSize`），几乎所有的`execute()`方法调用都是执行步骤2，而步骤2不需要获取全局锁

线程池处理流程图：

<img src="https://note.youdao.com/yws/public/resource/aba0f08fcb448be8bda00fbd1ddd049d/xmlnote/1938A70E46EA414AB7B7244FB2267EA1/5547" alt="image" style="zoom:67%;" />

#### **线程池的拒绝策略**

ThreadPoolExecutor.AbortPolicy：丢弃任务并抛出RejectedExecutionException异常（默认策略）
ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常
ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新提交被拒绝的任务
ThreadPoolExecutor.CallerRunsPolicy：由调用线程（提交任务的线程）处理该任务

### CyclicBarrrier和CountdownLatch

1. CountDownLatch的实现是基于AQS的，而CycliBarrier是基于 ReentrantLock(ReentrantLock也属于AQS同步器)和 Condition 的
2. CountDownLatch 是一个线程等待其他线程， CyclicBarrier 是多个线程互相等待
3. 调用CountDownLatch的countDown方法后，当前线程并不会阻塞，会继续往下执行；而调用CyclicBarrier的`await`方法，会阻塞当前线程
4. CountDownLatch只能使用过一次，CyclicBarrier在调用reset之后还可以继续使用

## 3.NIO

SelectorKey

Channel

## 4.JVM

### 内存模型

线程共有，线程私有

![](http://note.youdao.com/yws/public/resource/aba0f08fcb448be8bda00fbd1ddd049d/xmlnote/2A010FC6679A4C059F4CE6B26522FB06/11546)

#### Java堆内存分代管理

1. 新生代：

   - Eden空间：对象优先在Eden分配，空间不足时，虚拟机将发起一次Minor GC

   - From Survivor空间、To Survivor空间：在Minor GC时交替使用，达到一定次数后，对象会晋升到老年代。如果Minor GC后仍存活的对象无法放入Survivor，则通过分担带包机制提前将对象转移到老年代

     > ***为什么需要两个Survivor区*：**
     >
     > 设置两个Survivor区最大的好处就是解决了碎片化。
     >
     > 1. 如果只有一块Survivor区。Eden满了，第一次触发Minor GC，Eden中的存活对象被移动到Survivor区；再次触发Minor GC，Eden和Survivor各有一些存活对象： 
     >
     >    - 若此时把Eden区的存活对象直接放到Survivor区，这两部分对象所占有的内存是不连续的，导致了内存碎片化，严重影响Java程序的性能
     >
     >    - 若整理Survivor区后再放入Eden区的存活对象，则效率较低
     >
     > 2. 如果有两块Survivor区。第一次触发Minor GC，Eden中的存活对象就会被移动到第一块Survivor区S0，Eden被清空；再次触发Minor GC时，Eden和S0中的存活对象又会被复制送入第二块survivor区S1，S0和Eden被清空；然后下一轮S0与S1交换角色，如此循环往复。整个过程中，永远有一个Survivor区是空的，另一个非空的Survivor区无碎片

     > ***Eden区和Survivor区分配的大小比例：***
     >
     > 新生代中的对象98%是“朝生夕死”的，HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。

2. 老年代：大对象（需要大量连续内存空间）直接进入老年代；长期存活的对象进入老年代，对象每“熬过”一次Minor GC年龄增加一岁，到一定程度（默认为15岁）则晋升到老年代

3. 永久代：存储类定义、结构、字段、方法（数据及代码）以及常量在内的类相关数据

   > JDK 1.8中永久代被元空间（Metaspace）取代。两者本质类似，都是对JVM规范中方法区的实现，最大区别是：永久代的大小很难确定，对永久代的调优过程非常困难；元空间并不在虚拟机中，而是使用本地内存，最大可分配空间就是系统可用内存空间

> 是否所有的对象和数组都会在堆上分配内存（**逃逸分析**）
>
> 在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。

### 垃圾回收

![](http://note.youdao.com/yws/public/resource/aba0f08fcb448be8bda00fbd1ddd049d/xmlnote/12E1F654FFC743DB92996C0B7F9AA7EC/11552)

#### 垃圾回收策略

1. **引用计数法**：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加1，当引用失效时，计数器就减1；任何时刻计数器为0的对象就是不可能在被使用的

   主流的Java虚拟机里面没有选择引用计数算法来管理内存，其中主要的原因是它很难解决对象之间的相互循环引用的问题

2. **可达性分析法**：在主流的商用程序语言中使用。基本思路就是通过一系列的名为GC Roots的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连（对象不可达）时，则证明此对象是不可用的

#### 垃圾回收算法

标记-清除算法，复制算法，标记-整理算法，分代收集算法

1. 标记-清除算法：**回收老年代**。最基础的收集算法，分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象

   主要不足有两个：

   - **效率问题**，标记和清除两个过程的效率都不高；
   - **空间问题**，标记清除之后会产生大量不连续的内存碎片

2. 复制算法：**回收新生代**。为了解决效率问题，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。

3. 标记-整理算法：**回收老年代**。标记过程仍然与“标记-清除”算法一样，标记完成后让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存

4. 分代收集算法：当前商业虚拟机的垃圾收集都采用“分代收集”算法，根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法

   - 在新生代中选用复制算法
   - 老年代中使用“标记—清理”或者“标记—整理”算法来进行回收

#### 垃圾收集器

JDK1.6默认垃圾收集器：新生代ParNew，老年代Serial Old（一般使用CMS代替）

JDK1.8默认垃圾收集器：新生代Parallel Scavenge，老年代Parallel Old

| 收集器            | 执行方式 | 适用分代 | 算法               | 目标         | 适用场景                                  |
| ----------------- | -------- | -------- | ------------------ | ------------ | ----------------------------------------- |
| Serial            | 串行     | 新生代   | 复制算法           | 响应速度优先 | 单CPU环境下的Client模式                   |
| Serial Old        | 串行     | 老年代   | 标记-整理          | 响应速度优先 | 单CPU环境下的Client模式、CMS的后备预案    |
| ParNew            | 并行     | 新生代   | 复制算法           | 响应速度优先 | 多CPU环境时在Server模式下与CMS配合        |
| Parallel Scavenge | 并行     | 新生代   | 复制算法           | 吞吐量优先   | 在后台运算而不需要太多交互的任务          |
| Parallel Old      | 并行     | 老年代   | 标记-整理          | 吞吐量优先   | 在后台运算而不需要太多交互的任务          |
| CMS               | 并发     | 老年代   | 标记-清除          | 响应速度优先 | 集中在互联网站或B/S系统服务端上的Java应用 |
| G1                | 并发     | both     | 标记-整理+复制算法 | 响应速度优先 | 面向服务端应用，将来替换CMS               |

##### CMS收集器

CMS 收集器是一种 **“标记-清除”算法**实现的，整个过程分为四个步骤：

- **初始标记：** 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快
- **并发标记：** 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。
- **重新标记：** 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短
- **并发清除：** 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。

初始标记和重新标记会Stop The World；并发标记和并发清除耗时最长

##### G1收集器

G1 收集器的运作大致分为以下几个步骤：初始标记、并发标记、最终标记、筛选回收，使用 Region 划分内存空间以及有优先级的区域回收方式

#### GC调优

GC调优一般具体是通过GC日志的情况来分析。

1. 发现minor gc频繁，新生代空间太小了。
2. 如果发现晋升的年龄很小，老年代迅速被填满，导致频繁的major gc，并且回收比率又很大，那说明对象的生命周期确实很短也需要调整新生代。
3. 如果看full gc很频繁，但是每次回收的内存就一点点，那目测就是内存泄露了。

总体上就是根据分代的根本，也就是新生代朝生夕死的事实调整GC，避免分配大对象。具体还是得分析GC日志

### 类加载机制

****

**双亲委派模式**：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此

<img src="https://note.youdao.com/yws/public/resource/aba0f08fcb448be8bda00fbd1ddd049d/xmlnote/9B449FCD76974551A97D9A6AFA0975B3/5557" alt="image" style="zoom:67%;" />

**类的加载**：将编译好的class类文件中的字节码读入到内存中，将其放在方法区内创建对应的class对象，类的加载分为：加载、验证、准备、解析、初始化。加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的。

![image](https://note.youdao.com/yws/public/resource/aba0f08fcb448be8bda00fbd1ddd049d/xmlnote/F5D9C6FC016743B491D80D4310F63989/5559)

## 5.框架

### Spring

IoC、AOP，动态代理，Spring Bean生命周期

![](http://note.youdao.com/yws/public/resource/aba0f08fcb448be8bda00fbd1ddd049d/xmlnote/8E6E7B9664CA475EA1961D36C734E0C9/11548)

### Spring Boot

Spring Boot的启动过程

Spring Boot的自动装配机制

## 6.数据库（MySQL）

### SQL的执行过程 

![](http://note.youdao.com/yws/public/resource/aba0f08fcb448be8bda00fbd1ddd049d/xmlnote/DE5B0357E4124930A9A7476389E1FC5C/11545)

<img src="http://note.youdao.com/yws/public/resource/aba0f08fcb448be8bda00fbd1ddd049d/xmlnote/BAB9C28C002B4E6A8A22C9AFB3B999FA/11556" style="zoom:50%;" />

### 事务

1. 事务特性

   一致性，原子性，隔离性，永久性

2. 隔离级别

   读未提交，读已提交，可重复读，串行化

3. MVCC

### 索引

![](http://note.youdao.com/yws/public/resource/aba0f08fcb448be8bda00fbd1ddd049d/xmlnote/4E04B38ED784486286A182B50BDDB3CA/11554)

### 锁

共享锁，排它锁（行锁）

行锁的三种算法：

- Record Lock（单个行记录上的锁）

- Gap Lock（间隙锁）

- Next-Key Lock（锁定一个范围，并锁定锁本身）

意向共享锁，意向排它锁（表锁）

解决死锁：超时机制，等待图（锁的信息链表，事务等待链表）

**InnoDB有三种行锁的算法：**

1. Record Lock：单个行记录上的锁。

2. Gap Lock：间隙锁，锁定一个范围，但不包括记录本身。GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况。

3. Next-Key Lock：1+2，锁定一个范围，并且锁定记录本身。对于行的查询，都是采用该方法，主要目的是解决幻读的问题

### 日志

undolog，redolog，binlog

## 7.数据结构与算法



## 8.Redis

数据结构和使用场景

线程模型

## 9.Kafka

## 10.Dubbo