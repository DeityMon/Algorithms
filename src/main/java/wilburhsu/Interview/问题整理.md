[toc]

# 问题总结
## 1 Java基础
### 1.1 Java基础语法、语言特性
#### Java语言的特性，和其他语言的区别
1. 一次编写，处处运行。   
C语言和C++编写的代码编译成的机器码依赖于特定的运行环境，当运行环境改变或者更换CPU之后原来的代码需要作出很大的变动才能正常运行   
Java语言可以在不改变代码的情况下在不同的运行环境下正常运行，因为Java代码编译的时候并不是编译成机器代码，而是字节码这种中间代码，通过JVM把字节码边运行边解释成适合的机器码，保证了正常运行   
2. 安全性、多线程、动态等等优秀的特点
#### Java为什么可以跨平台
因为Java程序编译之后的代码不是能被硬件系统直接运行的代码，而是一种“中间码”——字节码。然后不同的硬件平台上安装有不同的Java虚拟机(JVM)，由JVM来把字节码再“翻译”成所对应的硬件平台能够执行的代码。因此对于Java编程者来说，不需要考虑硬件平台是什么，所以Java可以跨平台
### 1.2 Java关键字及常用方法
#### `final`关键字的作用
final可以用来修饰类，方法和变量（成员变量或局部变量）。   
1. 修饰类：final修饰类的时，表明该类不能被其他类所继承。注意：final类中所有的成员方法都会隐式的定义为final方法
2. 修饰方法：final修饰方法，表明该方法不能被重写。final修饰方法，表明该方法不能被重写。   
**注意**：类中所有private方法都是隐式的定义为final，为private方法添加final就毫无意义。
使用final方法的原因主要有两个：
    - 锁定方法，以防止继承类对其进行更改
    - 提升效率，在早期的java版本中，会将final方法转为内嵌调用，但若方法过于庞大，可能在性能上不会有多大提升。因此在最近版本中，不需要final方法进行这些优化了。
3. 修饰变量：
    - final修饰基本数据类型，表示该基本数据类型的值一旦在初始化后便不能发生变化；
    - final修饰引用类型，则在对其初始化之后便不能再让其指向其他对象了（不能再指向其他引用地址），但该引用所指向的对象的内容可以发生变化
    - final修饰成员变量，表示常量，只能被赋值一次，必须要显式初始化并且赋值后值不可改变。有两种初始化方式：在变量声明的时候初始化；在这个变量所在的类的所有的构造函数中对这个变量赋初值
    - final修饰函数的参数类型，说明该参数是只读型的。即你可以读取使用该参数，但是无法改变该参数的值
#### `final` `finally` `finalize`区别
1. final：可以用来修饰类，方法和变量（成员变量或局部变量）。
2. finally：`finally`作为异常处理的一部分，它只能用在`try...catch`语句中，并且附带一个语句块，表示这段语句最终（一般情况下）不管有没有抛出异常一定会被执行，经常被用在需要释放资源的情况下
    > 几种不会执行finally的情况：
    > ① 与`finally`对应的`try`语句块没有被执行
    > ② 在`try`语句块中执行了`System.exit(0)`语句，终止了Java虚拟机的运行
    > ③ 当一个线程在执行`try`语句块或者`catch`语句块时被打断（interrupted）或者被终止（killed）
    > ④ 在线程运行`try`语句块或者`catch`语句块时，突然死机或者断电
3. finalize：finalize()在java.lang.Object中定义，每一个对象都有这个方法。
    - 这个方法在GC启动，该对象被回收的时候被调用。
    - GC可以回收大部分的对象（凡是new出来的对象，GC都能回收），所以一般不需要程序员去实现finalize()。
    - 特殊情况下，需要程序员实现finalize()，比如：一个socket链接，在对象初始化时创建，整个生命周期内有效，那么就需要实现finalize()，关闭这个链接

#### `try...catch...finally`中`return`的执行结果
因为finally用法特殊，所以会撤销之前的return语句，继续执行最后的finally块中的代码。
```java
/**
 * try代码块已执行
 * try代码块已结束
 * finally代码块已执行
 * finally代码块已结束
 *
 * @return 3
 */
private int noErrorAndFinally() {
    try {
        System.out.println("try代码块已执行");
        System.out.println("try代码块已结束");
        return 1;
    } catch (Exception e) {
        System.out.println("catch代码块已执行");
        System.out.println("catch代码块已结束");
        return 2;
    } finally {
        System.out.println("finally代码块已执行");
        System.out.println("finally代码块已结束");
        return 3;
    }
}

/**
 * try代码块已执行
 * catch代码块已执行
 * catch代码块已结束
 * finally代码块已执行
 * finally代码块已结束
 *
 * @return 3
 */
private int hasErrorAndFinally() {
    try {
        System.out.println("try代码块已执行");
        int i = 1 / 0;
        System.out.println("i = " + i);
        System.out.println("try代码块已结束");
        return 1;
    } catch (Exception e) {
        System.out.println("catch代码块已执行");
        System.out.println("catch代码块已结束");
        return 2;
    } finally {
        System.out.println("finally代码块已执行");
        System.out.println("finally代码块已结束");
        return 3;
    }
}

/**
 * try代码块已执行
 * catch代码块已执行
 * catch代码块已结束
 *
 * @return 2
 */
private int hasErrorWithoutFinally() {
    try {
        System.out.println("try代码块已执行");
        int i = 1 / 0;
        System.out.println("i = " + i);
        System.out.println("try代码块已结束");
        return 1;
    } catch (Exception e) {
        System.out.println("catch代码块已执行");
        System.out.println("catch代码块已结束");
        return 2;
    }
}
```
#### `==`和`equals()`区别
1. 基本数据类型，也称原始数据类型。
`byte` `short` `char` `int` `long` `float` `double` `boolean`他们之间的比较，用`==`，比较的是他们的值
2. 复合数据类型（类）：
`==`：比较的是对象在内存中的存放地址；
基类Object中的基类中定义的`equals()`的方法，默认返回`==`运算的结果；
某些类中重写了`equals()`方法：`String` `Integer` `Double` `Date`等，返回值相等的结果

#### `equal()`和`hashCode()`的联系和区别
在Java中任何一个对象都具备`equals()`和`hashcode()`两个方法，因为他们是在`Object`类中定义的
1. `equals()`方法用来判断两个对象是否相同，如果相同则返回`true`，否则返回`false`
2. `hashcode()`方法返回`int`，在`Object`类中默认实现是：将该对象的内存地址转换成一个整数返回

其中两个重要规范
1. 【为什么重写`equals()`方法的同时要重写`hashCode()`方法】
如果`equals()`返回`true`，即两个对象相同，那么他们的`hashCode()`应该相等。因此，若重写`equals()`方法，有必要重写`hashCode()`方法，确保通过`equals()`方法判断结果为`true`的两个对象具备相等的`hashCode()`返回值。注意：这个只是规范，如果你非要写一个类让`equals()`返回`true`而`hashCode()`返回两个不相等的值，编译和运行都是不会报错的。不过这样违反了Java规范，程序也就埋下了BUG
2. 如果`equals()`返回`false`，即两个对象不相同，并不要求对这两个对象调用`hashCode()`方法得到两个不相同的数。说的简单点就是：如果两个对象不相同，他们的hashcode可能相同

【总结】根据这两个规范，可以得到如下推论： 
1. 如果两个对象`equals`，Java运行时环境会认为他们的`hashcode`一定相等【equals ＞ hashcode】
2. 如果两个对象不`equals`，他们的`hashcode`有可能相等
3. 如果两个对象`hashcode`相等，他们不一定`equals`【hashcode ≯ equals】
4. 如果两个对象`hashcode`不相等，他们一定不`equals` 

> `hashCode()`在哈希表中起作用，如`HashSet`、`HashMap`等。当我们向哈希表中添加对象`object`时，首先调用`hashCode()`方法计算`object`的哈希码，通过哈希码可以直接定位`object`在哈希表中的位置（一般是哈希码对哈希表大小取余）。如果该位置没有对象，可以直接将`object`插入该位置；如果该位置有对象，则调用`equals()`方法比较这些对象与`object`是否相等，如果相等，则不需要保存`object`；如果不相等，则将该对象加入到对应位置中

#### `static`关键字，是否可以覆盖一个`static`方法
static关键字表明一个成员变量或者是成员方法可以在没有所属的类实例变量的情况下被访问。被static标记的方法不能被覆盖，因为方法的覆盖是基于运行时动态绑定的，而static方法在编译时就已经和该类绑定了，也就是static标记的变量、方法都是随着类的加载而加载的，所以可以通过不创建对象实例就能访问该变量、方法；而不创建对象实例就访问非static变量、方法是不行的，因为此变量、方法还没有被创建。
- static标记的方法只能访问static变量或方法
- 非static标记的方法可以访问static或非static标记的变量或方法

#### `sleep()`和`wait()`的区别


### 1.3 面向对象
#### Java多态有哪几种，如何实现（重写如何定位到对应方法）
#### 重载和重写的区别
#### 接口和抽象类的区别

### 1.4 常用类、接口及集合类
#### `int` `Integer`的区别
#### `String`，`StringBuffer`，`StringBuilder`区别，`String`是否线程安全为什么
#### `Array` `ArrayList`区别
#### `ArrayList` `LinkedList`区别
#### `Comparable`接口和`Comparator`接口实现比较
#### `CopyOnWriteArrayList`类
#### `HashMap` 中`put`方法过程
#### `HashMap`基于什么数据结构实现
#### `HashMap`如何处理hash冲突，扩容过程
#### 如何让`HashMap`线程安全
#### `HashMap` `CurrentHashMap` `LinkedHashMap` `HashTable`区别
#### `CurrentHashMap`实现线程安全的关键（JDK1.7 分段锁）

## 2 Java高级
### 2.1 I/O
#### BIO与NIO、AIO的区别

### 2.2 锁
#### Java中的锁有几种
#### 乐观锁和悲观锁
#### `Synchronized` `ReentrantLock`区别
#### `Synchronized`底层实现
#### `volatile`的作用及适用场景
#### CAS
#### CAS会产生什么问题

### 2.3 多线程与并发
#### 线程安全怎么理解
#### 实现多线程有几种实现方式
#### 实现`Runnable`接口要实现什么方法
#### 【自行整理】线程池`ThreadPoolExecutor`
#### `ThreadPoolExcutor()`创建线程池的主要参数
#### 线程池有什么用，为什么要使用线程池
#### `ThreadLocal`
### 2.4 设计模式   
#### 什么是动态代理和静态代理
#### 静态代理和动态代理的优缺点
#### 动态代理的实现
#### 单例模式
### 2.5 反射

## 3 JVM
周志明 深入理解Java虚拟机（重点看2、3、7、12、13这五章）
### 3.1 内存管理
#### JVM内存模型，垃圾回收回收的是哪部分
#### Java堆内存分代管理
#### 为什么需要两个Survivor区
#### Eden区和Survivor区的分配的大小比例，为什么
#### 堆的永久代和JVM方法栈有什么区别
#### 如何判断对象是否存活
#### JVM最大内存限制
### 3.3 垃圾回收算法
#### 垃圾回收算法
#### 垃圾回收是否有内存泄漏的风险
#### 强引用、弱引用、软引用、虚引用
### 3.3 类加载机制
#### 解释ClassLoader，类加载器有几种，类加载器加载顺序
#### 哪个框架破坏了双亲委派模式
#### 类的生命周期（类加载过程）
#### 编译生成的class存放在哪
## 4 框架
深入分析Java Web技术内幕（1、2、5-11章）
### 4.1 Spring、Spring Boot
#### 为什么要用Spring框架开发
#### IoC AOP 理解
#### Spring bean生命周期
### 4.2 Mybatis
#### mybatis $#的区别，为什么#可以防止注入
#### mybatis的resultmap如何映射，复杂的result类如何序列化
## 5 数据库
### 5.1 事务
#### 数据库事务如何实现
#### 事务的特性
#### 事务隔离级别和可能遇到的问题
### 5.2 索引
#### MySQL索引类别
#### 索引数据结构，为什么用B+树而不是而不是B树，两者有什么区别
#### 组合索引，查询`c>5 a=1`是否命中索引`ac`和`ca`
### 5.3 锁
#### 数据库死锁是怎么造成的
#### MySQL如何处理死锁
#### InnoDB支持什么锁
### 5.4 引擎
#### MySQL引擎类别
### 5.5 SQL优化
#### limit为什么慢
#### 优化SQL `select * from t limit 1,100`
#### 数据库设计中遇到的问题
## 6 计算机网络
### 6.1 网络基础
#### `get`和`post`区别
#### `session`与`cookie`区别
#### 长连接和短链接
#### 从在浏览器输入网址到返回页面，经历了什么
### 6.2 TCP协议
#### TCP协议为什么是三次握手，两次为什么不可以
#### TCP链接通道里有什么，报文包含什么内容
#### TCP可靠传输（如果传输中丢失了报文如何处理）
#### TCP流量控制（如果发送方的速率高于接收方，如何避免接收缓存溢出）
#### TCP连接，其中一端断电会如何
## 7 操作系统
### 7.1 进程与线程
#### 线程进程的区别（资源、通信）
#### 线程有几种状态
### 7.2 死锁
#### 多线程死锁
#### 银行家算法
### 7.3 存储管理
#### 分页算法，FIFO、LRU
## 8 数据结构与算法
### 8.1 数据结构
#### 红黑树插入元素的过程（变色）
#### Java在哪里引入了红黑树
#### 为什么要引入红黑树
#### 红黑树的查找的时间复杂度
#### 队列和栈的区别
### 8.2 算法
#### 一句话描述动态规划，举一个生活中的例子
## 9 Linux
### 9.1 Linux命令
#### 使用 Linux命令找出日志文件中访问量最大的top10 IP地址
## 10 分布式中间件
Dubbo、Redis、Zookeeper、Kafka、Netty、MongoDB

## 11 项目
三个项目：   
一个侧重Java Web开发、设计与整体架构。   
一个侧重数据库优化。   
一个侧重产品创意团队协作   