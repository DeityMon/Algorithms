[toc]

# 问题总结
## 1 Java基础
### 1.1 Java基础语法、语言特性
#### Java语言的特性，和其他语言的区别
1. 一次编写，处处运行。   
C语言和C++编写的代码编译成的机器码依赖于特定的运行环境，当运行环境改变或者更换CPU之后原来的代码需要作出很大的变动才能正常运行   
Java语言可以在不改变代码的情况下在不同的运行环境下正常运行，因为Java代码编译的时候并不是编译成机器代码，而是字节码这种中间代码，通过JVM把字节码边运行边解释成适合的机器码，保证了正常运行   
2. 安全性、多线程、动态等等优秀的特点

#### Java为什么可以跨平台
因为Java程序编译之后的代码不是能被硬件系统直接运行的代码，而是一种“中间码”——字节码。然后不同的硬件平台上安装有不同的Java虚拟机(JVM)，由JVM来把字节码再“翻译”成所对应的硬件平台能够执行的代码。因此对于Java编程者来说，不需要考虑硬件平台是什么，所以Java可以跨平台

#### 为什么Java中只有值传递？
[为什么Java中只有值传递](https://github.com/Snailclimb/JavaGuide/blob/master/docs/essential-content-for-interview/MostCommonJavaInterviewQuestions/%E7%AC%AC%E4%B8%80%E5%91%A8%EF%BC%882018-8-7%EF%BC%89.md)

### 1.2 Java关键字及常用方法
#### `final`关键字的作用
final可以用来修饰类，方法和变量（成员变量或局部变量）。   
1. 修饰类：final修饰类的时，表明该类不能被其他类所继承。注意：final类中所有的成员方法都会隐式的定义为final方法
2. 修饰方法：final修饰方法，表明该方法不能被重写。final修饰方法，表明该方法不能被重写。   
**注意**：类中所有private方法都是隐式的定义为final，为private方法添加final就毫无意义。
使用final方法的原因主要有两个：
    - 锁定方法，以防止继承类对其进行更改
    - 提升效率，在早期的java版本中，会将final方法转为内嵌调用，但若方法过于庞大，可能在性能上不会有多大提升。因此在最近版本中，不需要final方法进行这些优化了。
3. 修饰变量：
    - final修饰基本数据类型，表示该基本数据类型的值一旦在初始化后便不能发生变化；
    - final修饰引用类型，则在对其初始化之后便不能再让其指向其他对象了（不能再指向其他引用地址），但该引用所指向的对象的内容可以发生变化
    - final修饰成员变量，表示常量，只能被赋值一次，必须要显式初始化并且赋值后值不可改变。有两种初始化方式：在变量声明的时候初始化；在这个变量所在的类的所有的构造函数中对这个变量赋初值
    - final修饰函数的参数类型，说明该参数是只读型的。即你可以读取使用该参数，但是无法改变该参数的值

#### `final` `finally` `finalize`区别
1. final：可以用来修饰类，方法和变量（成员变量或局部变量）。
2. finally：`finally`作为异常处理的一部分，它只能用在`try...catch`语句中，并且附带一个语句块，表示这段语句最终（一般情况下）不管有没有抛出异常一定会被执行，经常被用在需要释放资源的情况下
    > 几种不会执行finally的情况：
    > 1. 与`finally`对应的`try`语句块没有被执行
    > 2. 在`try`语句块中执行了`System.exit(0)`语句，终止了Java虚拟机的运行
    > 3. 当一个线程在执行`try`语句块或者`catch`语句块时被打断（interrupted）或者被终止（killed）
    > 4. 在线程运行`try`语句块或者`catch`语句块时，突然死机或者断电
3. finalize：finalize()在java.lang.Object中定义，每一个对象都有这个方法。
    - 这个方法在GC启动，该对象被回收的时候被调用。
    - GC可以回收大部分的对象（凡是new出来的对象，GC都能回收），所以一般不需要程序员去实现finalize()。
    - 特殊情况下，需要程序员实现finalize()，比如：一个socket链接，在对象初始化时创建，整个生命周期内有效，那么就需要实现finalize()，关闭这个链接

#### `try...catch...finally`中`return`的执行结果
因为finally用法特殊，所以会撤销之前的return语句，继续执行最后的finally块中的代码。
```java
/**
 * try代码块已执行
 * try代码块已结束
 * finally代码块已执行
 * finally代码块已结束
 *
 * @return 3
 */
private int noErrorAndFinally() {
    try {
        System.out.println("try代码块已执行");
        System.out.println("try代码块已结束");
        return 1;
    } catch (Exception e) {
        System.out.println("catch代码块已执行");
        System.out.println("catch代码块已结束");
        return 2;
    } finally {
        System.out.println("finally代码块已执行");
        System.out.println("finally代码块已结束");
        return 3;
    }
}

/**
 * try代码块已执行
 * catch代码块已执行
 * catch代码块已结束
 * finally代码块已执行
 * finally代码块已结束
 *
 * @return 3
 */
private int hasErrorAndFinally() {
    try {
        System.out.println("try代码块已执行");
        int i = 1 / 0;
        System.out.println("i = " + i);
        System.out.println("try代码块已结束");
        return 1;
    } catch (Exception e) {
        System.out.println("catch代码块已执行");
        System.out.println("catch代码块已结束");
        return 2;
    } finally {
        System.out.println("finally代码块已执行");
        System.out.println("finally代码块已结束");
        return 3;
    }
}

/**
 * try代码块已执行
 * catch代码块已执行
 * catch代码块已结束
 *
 * @return 2
 */
private int hasErrorWithoutFinally() {
    try {
        System.out.println("try代码块已执行");
        int i = 1 / 0;
        System.out.println("i = " + i);
        System.out.println("try代码块已结束");
        return 1;
    } catch (Exception e) {
        System.out.println("catch代码块已执行");
        System.out.println("catch代码块已结束");
        return 2;
    }
}
```
#### `==`和`equals()`区别
1. 基本数据类型，也称原始数据类型。
`byte` `short` `char` `int` `long` `float` `double` `boolean`他们之间的比较，用`==`，比较的是他们的值
2. 复合数据类型（类）：
`==`：比较的是对象在内存中的存放地址；
基类Object中的基类中定义的`equals()`的方法，默认返回`==`运算的结果；
某些类中重写了`equals()`方法：`String` `Integer` `Double` `Date`等，返回值相等的结果

#### `equal()`和`hashCode()`的联系和区别
在Java中任何一个对象都具备`equals()`和`hashcode()`两个方法，因为他们是在`Object`类中定义的
1. `equals()`方法用来判断两个对象是否相同，如果相同则返回`true`，否则返回`false`
2. `hashcode()`方法返回`int`，在`Object`类中默认实现是：将该对象的内存地址转换成一个整数返回

其中两个重要规范
1. 【为什么重写`equals()`方法的同时要重写`hashCode()`方法】
如果`equals()`返回`true`，即两个对象相同，那么他们的`hashCode()`应该相等。因此，若重写`equals()`方法，有必要重写`hashCode()`方法，确保通过`equals()`方法判断结果为`true`的两个对象具备相等的`hashCode()`返回值。注意：这个只是规范，如果你非要写一个类让`equals()`返回`true`而`hashCode()`返回两个不相等的值，编译和运行都是不会报错的。不过这样违反了Java规范，程序也就埋下了BUG
2. 如果`equals()`返回`false`，即两个对象不相同，并不要求对这两个对象调用`hashCode()`方法得到两个不相同的数。说的简单点就是：如果两个对象不相同，他们的hashcode可能相同

【总结】根据这两个规范，可以得到如下推论： 
1. 如果两个对象`equals`，Java运行时环境会认为他们的`hashcode`一定相等【equals ＞ hashcode】
2. 如果两个对象不`equals`，他们的`hashcode`有可能相等
3. 如果两个对象`hashcode`相等，他们不一定`equals`【hashcode ≯ equals】
4. 如果两个对象`hashcode`不相等，他们一定不`equals` 

> `hashCode()`在哈希表中起作用，如`HashSet`、`HashMap`等。当我们向哈希表中添加对象`object`时，首先调用`hashCode()`方法计算`object`的哈希码，通过哈希码可以直接定位`object`在哈希表中的位置（一般是哈希码对哈希表大小取余）。如果该位置没有对象，可以直接将`object`插入该位置；如果该位置有对象，则调用`equals()`方法比较这些对象与`object`是否相等，如果相等，则不需要保存`object`；如果不相等，则将该对象加入到对应位置中

详细的解释：https://www.cnblogs.com/skywang12345/p/3324958.html

#### `static`关键字，是否可以覆盖一个`static`方法
static关键字表明一个成员变量或者是成员方法可以在没有所属的类实例变量的情况下被访问。被static标记的方法不能被覆盖，因为方法的覆盖是基于运行时动态绑定的，而static方法在编译时就已经和该类绑定了，也就是static标记的变量、方法都是随着类的加载而加载的，所以可以通过不创建对象实例就能访问该变量、方法；而不创建对象实例就访问非static变量、方法是不行的，因为此变量、方法还没有被创建。
- static标记的方法只能访问static变量或方法
- 非static标记的方法可以访问static或非static标记的变量或方法

#### `sleep()`和`wait()`的区别
1. `wait()`属于`Object`类，`sleep()`属于`Thread`类
2. 两者最主要的区别在于：`wait()`会释放对象锁而`sleep()`不会释放锁
    - 在调用`sleep()`方法的过程中，线程不会释放对象锁
    - 当调用`wait()`方法的时候，线程会放弃对象锁，进入等待此对象的等待池，只有针对此对象调用`notify()`或`notifyAll()`方法后本线程才进入对象锁池准备获取对象锁进入运行状态（线程不会自动苏醒，需要别的线程调用同一个对象上的`notify()`或者`notifyAll()`方法）。
    - `sleep()`方法执行完成后，线程会自动苏醒。
3. `wait()`需要在同步块中使用，`sleep()`可以在任何地方使用；
4. `sleep()`需要捕获异常，`wait()`不需要
5. `wait()`通常被用于线程间交互/通信，`sleep()`通常被用于暂停执行。

#### 为什么我们调用`start()`方法时会执行`run()`方法，为什么我们不能直接调用`run()`方法？
new一个Thread，线程进入了新建状态；调用`start()`方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。`start()`会执行线程的相应准备工作，然后自动执行`run()`方法的内容，这是真正的多线程工作。而直接执行`run()`方法，会把run方法当成一个main线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。

总结： 调用`start()`方法方可启动线程并使线程进入就绪状态，而`run()`方法只是thread的一个普通方法调用，还是在主线程里执行。

### 1.3 面向对象
#### Java多态有哪几种，如何实现（重写如何定位到对应方法）
1. 多态：对象的多种形态。（严格意义上的多态，只是继承！）
    -  引用多态：
        1. 父类的引用可以指向本类的对象
        2. 父类的引用可以指向子类的对象
    - 方法多态：
        1. 创建本类对象时，调用的方法为本类方法
        2. 创建子类对象时，调用的方法为子类重写的方法或者继承的方法
2. 动态绑定
    ```java
    Object o = new GeometricObject();   // 声明类型为Object，实际类型为GeometricObject
    System.out.println(o.toString());
    ```
    1. 声明类型：一个变量必须被声明为某种类型，实例可以使用声明类型或它的子类型的构造方法创建
    2. 实际类型：被变量引用的对象的实际类型
    
    代码中，`o`调用的到底是哪个`toString()`方法是由`o`的实际类型决定的，这称为动态绑定。动态绑定的工作机制：假设对象`o`是类`C1` `C2` ... `C(i)` ... `C(n)`的实例，其中`C(i-1)` 是`C(i)`的子类，`C(n)`是最通用的类、`C1`是最特殊的类。在Java中`C(n)`是`Object`类。如果对象`o`调用一个方法p，那么Java虚拟机会依次在`C1` `C2` ... `C(n)`中查找方法p的实现，直到找到为止。一旦找到这个实现，就停止查找然后调用这个第一次找到的实现
    
    匹配方法的签名和绑定方法的实现是两个独立的事情：
    1. 引用变量的声明类型决定了编译时匹配哪个方法，编译器会在编译时，根据参数类型、参数个数、参数顺序找到匹配的方法（区分重载的方法）
    2. 实际类型决定Java虚拟机在运行时动态绑定方法的实现，一个方法可能在几个子类中都被实现

广义上的多态：https://www.runoob.com/java/java-polymorphism.html

#### 重载和重写的区别
- 重载： 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。 　　
- 重写： 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为 private 则子类就不能重写该方法。

#### 接口和抽象类的区别
1. 接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。
2. 接口中除了static、final变量，不能有其他变量，而抽象类中则不一定。
3. 一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过extends关键字扩展多个接口。
4. 接口方法默认修饰符是public，抽象方法可以有public、protected和default这些修饰符（抽象方法就是为了被重写所以不能使用private关键字修饰！）。
5. 从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。

&nbsp; | 变量 | 构造方法 | 方法
:---:|:---:|:---:|:---:
抽象类 | 无限制 | 子类通过构造方法链调用构造方法，<br>抽象类不能用new操作符实例化<br> | 无限制
接口 | 所有的变量必须是<br>`public`或`static`或`final`<br> | 没有加构造方法。<br>接口不能用new操作符实例化<br> | 所有方法必须是公共的抽象示例方法

### 1.4 常用类、接口及集合类
#### `int` `Integer`的区别
1. `Integer`是`int`的包装类，`int`则是Java的一种基本数据类型
2. `Integer`变量必须实例化后才能使用，而int变量不需要 
3. `Integer`实际是对象的引用，当`new Integer()`时，实际上是生成一个指针指向此对象；而`int`则是直接存储数据值 
4. `Integer`的默认值是`null`，`int`的默认值是0

关于`Integer`和`int`进行比较的结果
1. 由于`Integer`变量实际上是对一个`Integer`对象的引用，所以两个通过`new`生成的`Integer`变量永远是不相等的（因为内存地址不同）

    ```java
    // result: false
    Integer a = new Integer(100);
    Integer b = new Integer(100);
    ```

2. 对于两个非`new`生成的`Integer`对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为`true`，如果两个变量的值不在此区间，则比较结果为`false`

    ```java
    // result: true
    Integer a = 100;
    Integer b = 100;
    
    // result: false
    a = 128;
    b = 128;
    ```
    java在编译`Integer i = 100;`时，会翻译成为`Integer i = Integer.valueOf(100);`，而Java API中对`Integer.valueOf()`定义如下：对于-128到127之间的数，会进行缓存

    ```java
    /**
     * This method will always cache values in the range -128 to 127,
     * inclusive, and may cache other values outside of this range.
     */
    public static Integer valueOf(int i) {
        if (i >= IntegerCache.low && i <= IntegerCache.high)
            return IntegerCache.cache[i + (-IntegerCache.low)];
        return new Integer(i);
    }
    ```
3. 非`new Integer()`变量和`new Integer()`生成的变量比较时，结果为false
    1. 值在-128到127之间，非`new Integer()`变量在缓存中，`new Integer()`生成的变量为对象的引用，故不等
    
    ```java
    // result: false
    Integer a = 100;
    Integer b = new Integer(100);
    ```
    
    2. 值不在-128到127之间，两种方法生成的均为对象的引用，故不等
    
    ```java
    // result: false
    Integer a = 258;
    Integer b = new Integer(258);
    ```
    
4. Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较）
    
    ```java
    // result: true
    Integer a = new Integer(100);
    int c = 100;
    ```

#### `String`，`StringBuffer`，`StringBuilder`区别，`String`为什么不可变，是否线程安全为什么
可变性
1. `String` 类中使用 `final` 关键字修饰字符数组来保存字符串，`private　final　char　value[]`，所以 `String` 对象是不可变的
2. `StringBuilder` 与 `StringBuffer` 都继承自 `AbstractStringBuilder` 类，在 `AbstractStringBuilder` 中也是使用字符数组保存字符串`char[] value`，但是没有用 `final` 关键字修饰，所以这两种对象都是可变的。
3. `StringBuilder` 与 `StringBuffer` 的构造方法都是调用父类构造方法也就是 `AbstractStringBuilder` 实现的。`AbstractStringBuilder` 源码：

    ```java
    //AbstractStringBuilder.java
    abstract class AbstractStringBuilder implements Appendable, CharSequence {
        char[] value;
        int count;
        AbstractStringBuilder() {
        }
        AbstractStringBuilder(int capacity) {
            value = new char[capacity];
        }
    ```

线程安全性
1. `String` 中的对象是不可变的，也就可以理解为常量，线程安全。
2. `AbstractStringBuilder` 是 `StringBuilder` 与 `StringBuffer` 的公共父类，定义了一些字符串的基本操作，如 `expandCapacity`、`append`、`insert`、`indexOf` 等公共方法。
    1. `StringBuffer` 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。
    2. `StringBuilder` 并没有对方法进行加同步锁，所以是非线程安全的。　

性能
1. `String` `StringBuffer` `StringBuilder`都是`final`类，内部都是`char[]`实现，三者在执行速度方面：`StringBuilder` > `StringBuffer` > `String`
2. 每次对 `String` 类型进行改变的时候，都会生成一个新的 `String` 对象，然后将指针指向新的 `String` 对象。
3. `StringBuffer` 每次都会对 `StringBuffer` 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 `StringBuilder` 相比使用 `StringBuffer` 可以获得 10%~15% 左右的性能提升，但是要冒多线程不安全的风险。

使用总结
1. `String`，字符串常量，操作少量的数据用，类中定义的`char[]`是`final`的，不可变，因此是线程安全的
2. `StringBuffer`，字符串变量（线程安全），单线程操作字符串缓冲区下操作大量数据
3. `StringBuilder`，字符串变量（非线程安全），多线程操作字符串缓冲区下操作大量数据

> // 补充说明
> 为什么`String`要设计成不可变：https://www.cnblogs.com/sessionbest/articles/8688569.html
> 在java中，`String`被设计成final类，那为什么平时使用时，`String`的值可以被改变呢？
字符串常量池是java堆内存中一个特殊的存储区域，当我们建立一个String对象时，假设常量池不存在该字符串，则创建一个，若存在则直接引用已经存在的字符串。当我们对`String`对象值改变的时候，例如 `String a="A"`; `a="B"` 。a是`String`对象的一个引用（我们这里所说的`String`对象其实是指字符串常量），当`a="B"`执行时，并不是原本`String`对象(`"A"`)发生改变，而是创建一个新的对象(`"B"`)，令a引用它。    
> 笔试题：https://www.cnblogs.com/AmyZheng/p/9415064.html

#### `Comparable`接口和`Comparator`接口实现比较
1. Comparable

    `Comparable`接口中只有一个方法`compareTo()`，就是调用方法的当前对象`this`和`o`进行比较，若`this > o`则返回值大于0，`this = o`则返回值等于0，`this < o`则返回值小于0
    ```java
    public interface Comparable<T> {
        public int compareTo(T o);
    }
    ```
2. Comparator
    
    `Comparator`接口中方法很多，但是我们只需要实现一个`compare()`。
    > JDK8以后的新特性：在接口中用`default`修饰的方法可以有方法体，在实现接口的时候可以不用重写

    `compare()`比较`o1`和`o2`，`o1 > o2`则返回值大于0，以此类推。对于`compare()`来说`this`是谁不重要，所比较的两个对象都已经传入到方法中
    ```java
    public interface Comparator<T> {
        int compare(T o1, T o2);
        // default ... ...
    }
    ```
    `Comparator`可实现外部比较器，在我们设计类初时，并不需要它有比较功能，在后期扩展业务时，`Comparator`的存在可以使我们在不修改源代码的情况下来完成需求：只需要新定义一个比较器来实现`Comparator`，重写`compare()`方法并将类对象传进去
    ```java
    // 例子
    static class UserComparator implements Comparator<User> {
        @Override
        public int compare(User o1, User o2) {
            // ... ...
        }
    }
    ```

#### 常用集合类比较
集合 | 底层结构 | 存储类型 | 长度是否有上限 | 扩增/大小 | 线程安全 | 性能 | 备注
---|---|---|---|---|---|---|---
ArrayList | 数组 | 随机 | 有，`int hugeCapacity()` | 自动扩增/1.5倍 | 不安全 | 查询性能好 |
Vector | 数组 | 随机 | 有，`int hugeCapacity()` | 自动扩增/2倍 | 安全 | |
Stack | 数组 | 随机 | 有，`int hugeCapacity()` | 自动扩增/2倍 | 安全 | | 继承自Vector
LinkedList | 双向链表 | 顺序 | 无，直到内存满 | | 不安全 | 增加性能好 |
HashMap | | | 有，`MAXIMUM_CAPACITY = 1<<30` | 自动扩增/2倍 | 不安全 | |

#### `ArrayList`的实现，为什么查找效率高
`ArrayList`采用数组数组实现。查找效率高，因为`ArrayList`是连续存放元素的，找到第一个元素的首地址，再加上每个元素的占据的字节大小就能定位到对应的元素

#### `Array` `ArrayList`区别
`ArrayList`可以算是`Array`（`[]`）的加强版，`ArrayList`可以被想象成一种会自动扩增容量的`Array`
1. 存储内容
    1. `Array`数组可存放基本类型或对象类型；`Array`数组在存放的时候一定是同种类型的元素
    2. `ArrayList`只能包含对象类型；`ArrayList`可存放不同类型的元素，因为`ArrayList`可以存储`Object`
2. 空间大小
    1. `Array`最高效，但是其容量固定且无法动态改变
    2. `ArrayList`动态增长，但牺牲效率。若空间不够，会扩容1.5倍，然后将所有元素复制到新数组中并抛弃旧数组，每次添加新的元素的时候都会检查内部数组的空间是否足够
3. 相互转换

    ```java
    // ArrayList => Array
    ArrayList<Integer> arrayList = new ArrayList(10);
    Integer[] array = arrayList.toArray(new Integer[20]);
    
    // Array => ArrayList
    Integer[] array = new Integer[10];
    ArrayList<Integer> arrayList = new ArrayList(Arrays.asList(array));
    ```

#### `ArrayList` `LinkedList`区别
集合类 | `ArrayList` | `LinkedList`
---|---|---
继承关系 | `Collection<-List<-ArrayList` | `Collection<-List<-LinkedList`
底层数据结构 | 数组 | 双向链表
存取类型 | 随机存取 | 顺序存取
长度限制 | 有上限 `int hugeCapacity()` | 无上限 直到内存满
扩增/大小 | 自动扩增/1.5倍 | 
线程安全 | 不安全 | 不安全
性能 | 查询操作性能好 | 插入操作性能好

#### `CopyOnWriteArrayList`类
`CopyOnWriteArrayList` 是 `ArrayList` 的线程安全版本
1. 写操作：使用了一种叫写时复制的方法，当有新元素添加到`CopyOnWriteArrayList`时，先从原有的数组中拷贝一份出来，然后在新的数组做写操作，写完之后，再将原来的数组引用指向到新数组。整个`add()`操作都是在锁的保护下进行，避免在多线程并发`add()`的时候，复制出多个副本，导致最终的数组数据不是我们期望的
2. 读操作：读操作是可以不用加锁。如果有线程并发的读，则分几种情况： 
    1. 如果写操作未完成，那么直接读取原数组的数据
    2. 如果写操作完成，但是引用还未指向新数组，那么也是读取原数组数据
    3. 如果写操作完成，并且引用已经指向了新的数组，那么直接从新数组中读取数据

#### `HashMap` 中`put`方法过程
1. 对 Key 求 Hash 值，然后再计算下标。
2. 如果没有碰撞，直接放入桶中，
3. 如果碰撞了，以链表的方式链接到后面，
4. 如果链表长度超过阀值（TREEIFY_THRESHOLD == 8），就把链表转成红黑树。
5. 如果节点已经存在就替换旧值
6. 如果桶满了（容量 * 加载因子），就需要 resize。

#### `HashMap`基于什么数据结构实现
1. JDK1.8以前
    1. 数据结构：链表散列，数组+链表
    2. 键值对内部类：`Entry`
2. JDK1.8及以后
    1. 数据结构：数组+链表+红黑树（红黑树可提高效率）
    2. 键值对内部类：`Node`&`TreeNode`
    ```java
    static class Node<K,V> implements Map.Entry<K,V>{}
    static final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V>{}
    ```
#### ==`HashMap` 的长度为什么是2的幂次方==
#### `HashMap`如何处理hash冲突
链地址法
1. 计算出hash值，计算位置（因为n为table长度，为2的幂，故可用位运算计算余数）`i = (n - 1) & hash`
2. 若当前发生hash冲突
    - 找到相同key，则用带插入值覆盖原有值，返回旧值
    - 未找到相同key，则插入node，返回null
        1. 红黑树：添加节点
        2. 链表：在尾部插入

#### `HashMap` `CurrentHashMap` `LinkedHashMap` `HashTable`区别
接口`java.util.Map`，Map主要用于存储健值对，根据键得到值，因此不允许键重复（重复则覆盖），但允许值重复
1. Hashmap

    ```java
    public class HashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Cloneable, Serializable {}
    ```
    
    最常用的Map，它根据键的HashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。HashMap最多只允许一条记录的键为`Null`，允许多条记录的值为`Null`；`HashMap`不支持线程的同步，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要同步，可以用`Collections`的`synchronizedMap`方法使`HashMap`具有同步的能力，或者使用`ConcurrentHashMap`
2. `HashTable`
    
    ```java
    public class Hashtable<K,V> extends Dictionary<K,V> implements Map<K,V>, Cloneable, java.io.Serializable {}
    ```
    
    与HashMap类似，它继承自`Dictionary`类，不同的是：它不允许记录的键或者值为`Null`，它支持线程的同步，即任一时刻只有一个线程能写`Hashtable`，因此也导致了`Hashtable`在写入时会比较慢
3. `LinkedHashMap`
    
    ```java
    public class LinkedHashMap<K,V> extends HashMap<K,V> implements Map<K,V> {}
    ```
    
    `HashMap`的一个子类，保存了记录的插入顺序，在用`Iterator`遍历`LinkedHashMap`时，先得到的记录肯定是先插入的．也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比`HashMap`慢，不过有种情况例外，当`HashMap`容量很大，实际数据较少时，遍历起来可能会比`LinkedHashMap`慢，因为`LinkedHashMap`的遍历速度只和实际数据有关，和容量无关，而`HashMap`的遍历速度和容量有关
4. `ConcurrentHashMap`
    
    ```java
    public class ConcurrentHashMap<K,V> extends AbstractMap<K,V> implements ConcurrentMap<K,V>, Serializable {}
    public interface ConcurrentMap<K, V> extends Map<K, V> {}
    ```
    
    不允许key/value为空，`Concurrenthashmap`线程安全
    1. JDK1.7中采用`Segment`+`HashEntry`实现，lock加在`Segment`上
    2. JDK1.8中采用`Node`+`CAS`+`Synchronized`实现

#### 如何让`HashMap`线程安全 | `HashTable`、`ConcurrentHashmap`如何实现线程安全
1. `HashTable`的方式：将容器中数据进行操作的方法用`synchronized`关键字修饰
2. `ConcurrentHashMap`的方式：采用分段锁思路，`segment`+`HashEntry`（JDK1.7）；`Node`+`CAS`+`Synchronized`（JDK1.8）

#### `CurrentHashMap`实现线程安全的关键（JDK1.7 分段锁）
[ConcurrentHashMap实现原理及源码分析](https://www.cnblogs.com/chengxiao/p/6842045.html)

JDK1.7中采用`Segment`+`HashEntry`实现，lock加在`Segment`上。`Segment`继承了`ReentrantLock`，所以它就是一种可重入锁。在`ConcurrentHashMap`，一个`Segment`就是一个子哈希表，`Segment`里维护了一个`HashEntry`数组，并发环境下，对于不同`Segment`的数据进行操作是不用考虑锁竞争的，对于同一个Segment的操作才需考虑线程同步
1. `get()`方法：先定位`Segment`，再定位`HashEntry`。`get()`方法无需加锁，由于其中涉及到的共享变量都使用`volatile`修饰，`volatile`可以保证内存可见性，所以不会读取到过期数据
2. `put()`方法
    1. 定位segment并确保定位的Segment已初始化
    2. 调用Segment的put方法：`tryLock()`不成功时会遍历定位到的`HashEnry`位置的链表（遍历主要是为了使CPU缓存链表），若找不到，则创建`HashEntry`。`tryLock()`一定次数后，则lock。若遍历过程中，由于其他线程的操作导致链表头结点变化，则需要重新遍历

## 2 Java高级
### 2.1 I/O
#### BIO与NIO、AIO的区别
1. Java中的典型IO操作模式
    1. 同步阻塞模式：Java中的BIO风格的API
        
    ```java
    Socket socket = getSocket();
    socket.getInputStream().read(); //读不到数据誓不返回
    ```
        
    该模式下，最直观的感受就是如果IO设备暂时没有数据可供读取，调用API就卡住了，如果数据一直不来就一直卡住
    2. 同步非阻塞模式：Java中的NIO风格的API
        
    ```java
    SocketChannel socketChannel = getSocketChannel(); //获取non-blocking状态的Channel
    socketChannel.read(ByteBuffer.allocate(4)); //读不到数据就算了，立即返回0告诉你没有读到
    ```
    
    该模式下，通常需要不断调用API，直至读取到数据，不过好在函数调用不会卡住，想继续尝试读取或者先去做点其他事情再来读取都可以
    3. 异步非阻塞模式：Java中的AIO风格的API
        
    ```java
    AsynchronousSocketChannel asynchronousSocketChannel = getAsynchronousSocketChannel();
    asynchronousSocketChannel.read(ByteBuffer.allocate(4), null, new CompletionHandler<Integer, Object>() {
        @Override
        public void completed(Integer result, Object attachment) {
            //读不到数据不会触发该回调来烦你，只有确实读取到数据，且把数据已经存在ByteBuffer中了，API才会通过此回调接口主动通知您
        }
        @Override
        public void failed(Throwable exc, Object attachment) {
        }
    });
    
    ```
    读不到数据不会触发该回调来烦你，只有确实读取到数据，且把数据已经存在`ByteBuffer`中了，API才会通过此回调接口主动通知您
2. Java对BIO、NIO、AIO的支持
    1. BIO
        1. 同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善
        2. 适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解
    2. NIO
        1. 同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理
        2. 适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持
    3. AIO
        1. 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理
        2. 适用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持

    另外，I/O属于底层操作，需要操作系统支持，并发也需要操作系统的支持，所以性能方面不同操作系统差异会比较明显。

> 1. 同步：自己亲自出马持银行卡到银行取钱（使用同步IO时，Java自己处理IO读写）；
> 2. 异步：委托一小弟拿银行卡到银行取钱，然后给你（使用异步IO时，Java将IO读写委托给OS处理，需要将数据缓冲区地址和大小传给OS(银行卡和密码)，OS需要支持异步IO操作API）；
> 3. 阻塞：ATM排队取款，你只能等待（使用阻塞IO时，Java调用会一直阻塞到读写完成才返回）；
> 4. 非阻塞：柜台取款，取个号，然后坐在椅子上做其它事，等号广播会通知你办理，没到号你就不能去，你可以不断问大堂经理排到了没有，大堂经理如果说还没到你就不能去（使用非阻塞IO时，如果不能读写Java调用会马上返回，当IO事件分发器会通知可读写时再继续进行读写，不断循环直到读写完成）

> 一般来说I/O模型可以分为：同步阻塞，同步非阻塞，异步阻塞，异步非阻塞IO
> 1. 同步阻塞IO：在此种方式下，用户进程在发起一个IO操作以后，必须等待IO操作的完成，只有当真正完成了IO操作以后，用户进程才能运行。JAVA传统的IO模型属于此种方式！
> 2. 同步非阻塞IO:在此种方式下，用户进程发起一个IO操作以后边可返回做其它事情，但是用户进程需要时不时的询问IO操作是否就绪，这就要求用户进程不停的去询问，从而引入不必要的CPU资源浪费。其中目前JAVA的NIO就属于同步非阻塞IO。
> 3. 异步阻塞IO：此种方式下是指应用发起一个IO操作以后，不等待内核IO操作的完成，等内核完成IO操作以后会通知应用程序，这其实就是同步和异步最关键的区别，同步必须等待或者主动的去询问IO是否完成，那么为什么说是阻塞的呢？因为此时是通过select系统调用来完成的，而select函数本身的实现方式是阻塞的，而采用select函数有个好处就是它可以同时监听多个文件句柄，从而提高系统的并发性！
> 4. 异步非阻塞IO:在此种模式下，用户进程只需要发起一个IO操作然后立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知，此时用户进程只需要对数据进行处理就好了，不需要进行实际的IO读写操作，因为真正的IO读取或者写入操作已经由内核完成了。目前Java中还没有支持此种IO模型

### 2.2 多线程与并发
#### 线程安全怎么理解
当多个线程访问某个方法时，不管你通过怎样的调用方式或者说这些线程如何交替的执行，我们在主程序中不需要去做任何的同步，这个类的结果行为都是我们设想的正确行为，那么我们就可以说这个类是线程安全的

#### 实现多线程有几种实现方式
[https://www.cnblogs.com/songshu120/p/7966314.html](https://www.cnblogs.com/songshu120/p/7966314.html)
1. 继承`Thread`类创建线程类
    1. 定义`Thread`类的子类，并重写该类的`run()`方法，该`run()`方法的方法体就代表了线程要完成的任务，因此把`run()`方法称为执行体
    2. 创建`Thread`子类的实例，即创建了线程对象
    3. 调用线程对象的`start()`方法来启动该线程
2. 通过`Runnable`接口创建线程类：线程的执行流程很简单，当执行代码`start()`时，就会执行对象中重写的`run()`方法，该方法执行完成后，线程就消亡了
    1. 定义`Runnable`接口的实现类，并重写该接口的`run()`方法，该`run()`方法的方法体同样是该线程的线程执行体
    2. 创建`Runnable`实现类的实例，并以此实例作为`Thread`的`target`来创建`Thread`对象，该`Thread`对象才是真正的线程对象
    3. 调用线程对象的`start()`方法来启动该线程
3. 通过`Callable`和`Future`创建线程
    1. 创建`Callable`接口的实现类，并实现`call()`方法，该`call()`方法将作为线程执行体，并且有返回值
    2. 创建`Callable`实现类的实例，使用`FutureTask`类来包装`Callable`对象，该`FutureTask`对象封装了该`Callable`对象的`call()`方法的返回值（`FutureTask`是一个包装器，它通过接受`Callable`来创建，它同时实现了`Future`和`Runnable`接口）
    3. 使用`FutureTask`对象作为`Thread`对象的`target`创建并启动新线程
    4. 调用`FutureTask`对象的`get()`方法来获得子线程执行结束后的返回值

#### 实现`Runnable`接口要实现什么方法
[JAVA多线程实现的四种方式](https://www.cnblogs.com/felixzh/p/6036074.html)

Java多线程实现方式主要有四种：继承Thread类、实现Runnable接口、实现Callable接口通过FutureTask包装器来创建Thread线程、使用ExecutorService、Callable、Future实现有返回结果的多线程。

其中前两种方式线程执行完后都没有返回值，后两种是带返回值的。

1. 继承Thread类创建线程
    Thread类本质上是实现了Runnable接口的一个实例，代表一个线程的实例。启动线程的唯一方法就是通过Thread类的start()实例方法。start()方法是一个native方法，它将启动一个新线程，并执行run()方法。这种方式实现多线程很简单，通过自己的类直接extend Thread，并复写run()方法，就可以启动新线程并执行自己定义的run()方法。例如：
    ```java
    public class MyThread extends Thread {  
    　　public void run() {  
    　　 System.out.println("MyThread.run()");  
    　　}  
    }  
     
    MyThread myThread1 = new MyThread();  
    MyThread myThread2 = new MyThread();  
    myThread1.start();  
    myThread2.start();
    ```
2. 实现Runnable接口创建线程
    如果自己的类已经extends另一个类，就无法直接extends Thread，此时，可以实现一个Runnable接口，如下：
    ```java
    public class MyThread extends OtherClass implements Runnable {  
    　　public void run() {  
    　　 System.out.println("MyThread.run()");  
    　　}  
    }
    ```
    为了启动MyThread，需要首先实例化一个Thread，并传入自己的MyThread实例：
    ```java
    MyThread myThread = new MyThread();  
    Thread thread = new Thread(myThread);  
    thread.start(); 
    ```
    事实上，当传入一个Runnable target参数给Thread后，Thread的run()方法就会调用target.run()，参考JDK源代码：
    ```java
    public void run() {  
    　　if (target != null) {  
    　　 target.run();  
    　　}  
    }
    ```
3. 实现Callable接口通过FutureTask包装器来创建Thread线程
    Callable接口（也只有一个方法）定义如下：
    ```java
    public interface Callable<V> { 
      V call（） throws Exception;
    }
    ```
    ```java
    public class SomeCallable<V> extends OtherClass implements Callable<V> {
        @Override
        public V call() throws Exception {
            // TODO Auto-generated method stub
            return null;
        }
    }
    ```
    ```java
    Callable<V> oneCallable = new SomeCallable<V>();   
    //由Callable<Integer>创建一个FutureTask<Integer>对象：   
    FutureTask<V> oneTask = new FutureTask<V>(oneCallable);   
    //注释：FutureTask<Integer>是一个包装器，它通过接受Callable<Integer>来创建，它同时实现了Future和Runnable接口
    //由FutureTask<Integer>创建一个Thread对象：
    Thread oneThread = new Thread(oneTask);   
    oneThread.start();   
    //至此，一个线程就创建完成了
    ```

4. 使用ExecutorService、Callable、Future实现有返回结果的线程
    - ExecutorService、Callable、Future三个接口实际上都是属于Executor框架。返回结果的线程是在JDK1.5中引入的新特征，有了这种特征就不需要再为了得到返回值而大费周折了。而且自己实现了也可能漏洞百出。
    - 可返回值的任务必须实现Callable接口。类似的，无返回值的任务必须实现Runnable接口。
    - 执行Callable任务后，可以获取一个Future的对象，在该对象上调用get就可以获取到Callable任务返回的Object了。
    注意：get方法是阻塞的，即：线程无返回结果，get方法会一直等待。
    - 再结合线程池接口ExecutorService就可以实现传说中有返回结果的多线程了。
    - 下面提供了一个完整的有返回结果的多线程测试例子，在JDK1.5下验证过没问题可以直接使用。代码如下：
    ```java
    import java.util.concurrent.*;
    import java.util.Date;
    import java.util.List;
    import java.util.ArrayList;
    
    /**
     * 有返回值的线程
     */
    @SuppressWarnings("unchecked")
    public class Test {
        public static void main(String[] args) throws ExecutionException,
                InterruptedException {
            System.out.println("----程序开始运行----");
            Date date1 = new Date();
    
            int taskSize = 5;
            // 创建一个线程池  
            ExecutorService pool = Executors.newFixedThreadPool(taskSize);
            // 创建多个有返回值的任务  
            List<Future> list = new ArrayList<Future>();
            for (int i = 0; i < taskSize; i++) {
                Callable c = new MyCallable(i + " ");
                // 执行任务并获取Future对象  
                Future f = pool.submit(c);
                // System.out.println(">>>" + f.get().toString());  
                list.add(f);
            }
            // 关闭线程池  
            pool.shutdown();
    
            // 获取所有并发任务的运行结果  
            for (Future f : list) {
                // 从Future对象上获取任务的返回值，并输出到控制台  
                System.out.println(">>>" + f.get().toString());
            }
    
            Date date2 = new Date();
            System.out.println("----程序结束运行----，程序运行时间【"
                    + (date2.getTime() - date1.getTime()) + "毫秒】");
        }
    }
    
    class MyCallable implements Callable<Object> {
        private String taskNum;
    
        MyCallable(String taskNum) {
            this.taskNum = taskNum;
        }
    
        public Object call() throws Exception {
            System.out.println(">>>" + taskNum + "任务启动");
            Date dateTmp1 = new Date();
            Thread.sleep(1000);
            Date dateTmp2 = new Date();
            long time = dateTmp2.getTime() - dateTmp1.getTime();
            System.out.println(">>>" + taskNum + "任务终止");
            return taskNum + "任务返回运行结果,当前任务时间【" + time + "毫秒】";
        }
    }
    ```   
#### 【自行整理】线程池`ThreadPoolExecutor`
1. `ThreadPoolExecutor`执行`execute()`方法分4步：
    1. 如果当前运行的线程少于`corePoolSize`，则创建新线程来执行任务（需要获取全局锁）
    2. 如果运行的线程等于或多于`corePoolSize`，则将任务加入`BlockingQueue`
    3. 如果无法将任务加入`BlockingQueue`（队列已满），则创建新的线程来处理任务（需要获取全局锁）
    4. 如果创建新线程将使当前运行的线程超出`maximumPoolSize`，任务将被拒绝，并调用`RejectedExecutionHandler.rejectedExecution()`方法
    
    `ThreadPoolExecutor`采取上述步骤的总体设计思路，是为了在执行`execute()`方法时，尽可能地避免获取全局锁（那将会是一个严重的可伸缩瓶颈）。在`ThreadPoolExecutor`完成预热之后（当前运行的线程数大于等于`corePoolSize`），几乎所有的`execute()`方法调用都是执行步骤2，而步骤2不需要获取全局锁
    
    线程池处理流程图：
    
    ![image](https://note.youdao.com/yws/public/resource/be02344987843483827564c4dc494b13/xmlnote/4A8F300DE6C6478DB5D4798E9206FF16/8337)
2. 线程池中的线程执行任务分2步：
    1. 在`execute()`方法中创建一个线程时，会让这个线程执行当前任务
    2. 这个线程执行完任务后，会反复从`BlockingQueue`获取任务来执行

#### `ThreadPoolExcutor()`创建线程池的主要参数
```java
new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, milliseconds,runnableTaskQueue, handler);
```
1. `corePoolSize`：线程池的基本大小。当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的`prestartAllCoreThreads()`方法，线程池会提前创建并启动所有基本线程
2. `runnableTaskQueue`：任务队列。用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列
    1. `ArrayBlockingQueue`：基于数组结构的有界阻塞队列，此队列按FIFO（先进先出）原则对元素进行排序
    2. `LinkedBlockingQueue`：基于链表结构的阻塞队列，此队列按FIFO排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列
    3. `SynchronousQueue`：不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于Linked-BlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列
    4. `PriorityBlockingQueue`：具有优先级的无限阻塞队列
3. `maximumPoolSize`：线程池最大数量。线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是，如果使用了无界的任务队列这个参数就没什么效果
4. `ThreadFactory`：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。使用开源框架`guava`提供的`ThreadFactoryBuilder`可以快速给线程池里的线程设置有意义的名字
5. `RejectedExecutionHandler`：饱和策略。当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是`AbortPolicy`，表示无法处理新任务时抛出异常。在JDK 1.5中Java线程池框架提供了以下4种策略：
    1. `AbortPolicy`：直接抛出异常
    2. `CallerRunsPolicy`：只用调用者所在线程来运行任务
    3. `DiscardOldestPolicy`：丢弃队列里最近的一个任务，并执行当前任务
    4. `DiscardPolicy`：不处理，丢弃掉
#### 线程池有什么用，为什么要使用线程池
1. 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 
2. 提高响应速度。当任务到达时，任务可以不需要等到线程创建就能执行。
3. 提高线程的可管理性，线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。

#### `ThreadLocal`
https://www.jianshu.com/p/98b68c97df9b

`ThreadLocal`是一个本地线程副本变量工具类。多线程中的对象使用`ThreadLocal`维护时，`ThreadLocal`为每个使用该变量的线程分配一个独立的变量副本，每个线程可以独立地改变自己的副本，不会影响其他线程对应的副本

1. 实现思路：
    1. 每个`Thread`线程内部都有一个`ThreadLocalMap`，`ThreadLocalMap`里面存储一份线程自己的变量副本：
    &emsp;&emsp;&emsp;1. key：线程本地对象（变量对应的`ThreadLocal`实例）
    &emsp;&emsp;&emsp;2. value：线程的变量副本（变量的本地值）
    
    ```java
    ThreadLocal.ThreadLocalMap threadLocals = null;
    // ThreadLocalMap内的Entry
    Entry(ThreadLocal<?> k, Object v) {}
    ```

    2. `Thread`内部的`ThreadLocalMap`由`ThreadLocal`维护的，由`ThreadLocal`负责向`ThreadLocalMap`获取和设置线程的变量值
2. 方法：
    1. `get()`：用于获取当前线程的副本变量值
    2. `set()`：用于保存当前线程的副本变量值
    3. `initialValue()`：为当前线程初始副本变量值
    4. `remove()`：移除当前前程的副本变量值。
3. Hash冲突解决：采用线性探测的方式，根据初始`key`的`hashcode`确定元素在`table`数组中的位置，如果发现这个位置上已经有其他`key`的元素，则利用固定的算法寻找一定步长的下个位置，依次判断，直至找到能够存放的位置。`ThreadLocalMap`解决Hash冲突的方式就是简单的步长加1或减1
    
    ```java
    // get()时使用
    private static int nextIndex(int i, int len) {
        return ((i + 1 < len) ? i + 1 : 0);
    }
    
    // set()时使用
    private static int prevIndex(int i, int len) {
        return ((i - 1 >= 0) ? i - 1 : len - 1);
    }
    ```
    
4. `ThreadLocalMap`的问题：由于`ThreadLocalMap`的`key`是弱引用，而`value`是强引用。这就导致`ThreadLocal`在没有外部对象强引用时，发生GC时弱引用`key`会被回收，而`value`不会回收，如果创建`ThreadLocal`的线程一直持续运行，那么这个`Entry`对象中的`value`就有可能一直得不到回收，发生内存泄露。避免泄漏：在调用`ThreadLocal`的`get()` `set()`方法使用完成后调用`remove()`方法，将`Entry`节点和`Map`的引用关系移除，这样整个`Entry`对象在GC Roots分析后就变成不可达了，下次GC的时候就可以被回收
    
    ```java
    ThreadLocal<Session> threadLocal = new ThreadLocal<Session>();
    try {
        threadLocal.set(new Session(1, "Misout的博客"));
        // 其它业务逻辑
    } finally {
        threadLocal.remove();
    }
    ```

### 2.3 锁
#### Java中的锁有几种
1. `synchronized`关键字
2. `java.util.concurrent.locks`包下常用的类
    1. `ReentrantLock`：可重入锁，实现了`Lock`接口，并且提供了更多的方法
    2. `ReentrantReadWriteLock`：可重入的读写锁，实现了`ReadWriteLock`接口，最主要的有两个方法：`readLock()`和`writeLock()`用来获取读锁和写锁
    3. `StampedLock`：JDK8新增，该锁提供了三种模式的读写控制
    &emsp;&emsp;&emsp;1. 写锁writeLock，是个排它锁或者叫独占锁
    &emsp;&emsp;&emsp;2. 悲观读锁readLock，是个共享锁
    &emsp;&emsp;&emsp;3. 乐观读锁tryOptimisticRead（在操作数据前并没有通过CAS设置锁的状态）

#### 乐观锁和悲观锁
1. 悲观锁
    1. 总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）
    2. 传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中`synchronized`和`ReentrantLock`等独占锁就是悲观锁思想的实现
2. 乐观锁
    1. 总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现
    2. 乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于`write_condition`机制，其实都是提供的乐观锁。Java中`java.util.concurrent.atomic`包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的

#### `Synchronized` `ReentrantLock`区别
1. 相似点：都是加锁方式同步，而且都是阻塞式的同步，也就是说当如果一个线程获得了对象锁，进入了同步块，其他访问该同步块的线程都必须阻塞在同步块外面等待，而进行线程阻塞和唤醒的代价是比较高的
2. 功能区别
    1. `Synchronized`是java语言的关键字，是原生语法层面的互斥，需要jvm实现
    2. `ReentrantLock`它是JDK1.5之后提供的API层面的互斥锁，需要`lock()`和`unlock()`方法配合`try/finally`语句块来完成
3. 便利性
    1. `Synchronized`的使用比较方便简洁，并且由编译器去保证锁的加锁和释放
    2. `ReenTrantLock`需要手工声明来加锁和释放锁，为了避免忘记手工释放锁造成死锁，所以最好在`finally`中声明释放锁
4. 锁的细粒度和灵活度：很明显`ReenTrantLock`优于`Synchronized`
5. 性能的区别：在`Synchronized`优化以前，`synchronized`的性能是比`ReenTrantLock`差很多，但是自从`Synchronized`引入了偏向锁、轻量级锁（自旋锁）后，两者的性能就差不多了。（在两种方法都可用的情况下，官方甚至建议使用`synchronized`）
    > 其实synchronized的优化感觉就借鉴了ReenTrantLock中的CAS技术。都是试图在用户态就把加锁问题解决，避免进入内核态的线程阻塞。

#### ==`Synchronized`底层实现==

#### `volatile`的作用及适用场景
[Java 理论与实践：正确使用 Volatile 变量](https://www.ibm.com/developerworks/cn/java/j-jtp06197.html)

`volatile`是轻量级的`synchronized`，它在多处理器开发中保证了共享变量的“可见性”：当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值

只能在有限的一些情形下使用`volatile`变量替代锁，例如：状态标志。要` volatile`变量提供理想的线程安全，必须同时满足下面两个条件：
1. 对变量的写操作不依赖于当前值：不能用作线程安全计数器：虽然增量操作`x++`看上去类似一个单独操作，实际上它是一个由读取－修改－写入操作序列组成的组合操作，必须以原子方式执行，`volatile`不能提供必须的原子特性
2. 该变量没有包含在具有其他变量的不变式中

#### CAS
CAS是英文单词Compare And Swap的缩写，翻译过来就是比较并替换。

CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B，具体过程：
1. 在内存地址V当中，存储着值为10的变量
2. 此时线程1想要把变量的值增加1。对线程1来说，旧的预期值A=10，要修改的新值B=11
3. 在线程1要提交更新之前，另一个线程2抢先一步，把内存地址V中的变量值率先更新成了11
4. 线程1开始提交更新，首先进行A和地址V的实际值比较Compare，发现A不等于V的实际值，提交失败
5. 线程1重新获取内存地址V的当前值，并重新计算想要修改的新值。此时对线程1来说，A=11，B=12。这个重新尝试的过程被称为自旋
6. 这一次比较幸运，没有其他线程改变地址V的值。线程1进行Compare，发现A和地址V的实际值是相等的
7. 线程1进行SWAP，把地址V的值替换为B，也就是12
从思想上来说，Synchronized属于悲观锁，悲观地认为程序中的并发情况严重，所以严防死守。CAS属于乐观锁，乐观地认为程序中的并发情况不那么严重，所以让线程不断去尝试更新。

CAS的缺点：
1. CPU开销较大。在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。
2. 不能保证代码块的原子性。CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized了

#### CAS会产生什么问题
CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。
1. CPU开销较大：在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力
2. 不能保证代码块的原子性：CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized了
3. ABA问题：CAS机制最大的问题所在。线程1准备用CAS将变量的值由A替换为B，在此之前，线程2将变量的值由A替换为C，又由C替换为A，然后线程1执行CAS时发现变量的值仍然为A，所以CAS成功。但实际上这时的现场已经和最初不同了，尽管CAS成功，但可能存在潜藏的问题，例如：
    1. 一个用单向链表实现的堆栈，栈顶为A，这时线程T1已经知`A.next`为B，希望用CAS将栈顶替换为B
        
    ```
    graph LR
    A-->B
    ```
        
    2. 在T1执行上面这条指令之前，线程T2介入，将A、B出栈，再`push D C A`，此时堆栈结构如下图，而对象B此时处于游离状态
        
    ```
    graph LR
    A-->C
    C-->D
    ```
        
    3. 此时轮到线程T1执行CAS操作，检测发现栈顶仍为A，所以CAS成功，栈顶变为B，但实际上`B.next`为null，所以此时的情况变为
        
    ```
    graph LR
    B
    C-->D
    ```

### 2.4 设计模式   
#### 什么是动态代理和静态代理


#### 静态代理和动态代理的优缺点
#### 动态代理的实现
#### 单例模式
### 2.5 反射

## 3 JVM
周志明 深入理解Java虚拟机（重点看2、3、7、12、13这五章）
### 3.1 内存管理
#### JVM内存模型，垃圾回收回收的是哪部分
#### Java堆内存分代管理
#### 为什么需要两个Survivor区
#### Eden区和Survivor区的分配的大小比例，为什么
#### 堆的永久代和JVM方法栈有什么区别
#### 如何判断对象是否存活
#### JVM最大内存限制
### 3.3 垃圾回收算法
#### 垃圾回收算法
#### 垃圾回收是否有内存泄漏的风险
#### 强引用、弱引用、软引用、虚引用
### 3.3 类加载机制
#### 解释ClassLoader，类加载器有几种，类加载器加载顺序
#### 哪个框架破坏了双亲委派模式
#### 类的生命周期（类加载过程）
#### 编译生成的class存放在哪
## 4 框架
深入分析Java Web技术内幕（1、2、5-11章）
### 4.1 Spring、Spring Boot
#### 为什么要用Spring框架开发
#### IoC AOP 理解
#### Spring bean生命周期
### 4.2 Mybatis
#### mybatis $#的区别，为什么#可以防止注入
#### mybatis的resultmap如何映射，复杂的result类如何序列化
## 5 数据库
### 5.1 事务
#### 数据库事务如何实现
#### 事务的特性
#### 事务隔离级别和可能遇到的问题
### 5.2 索引
#### MySQL索引类别
#### 索引数据结构，为什么用B+树而不是而不是B树，两者有什么区别
#### 组合索引，查询`c>5 a=1`是否命中索引`ac`和`ca`
### 5.3 锁
#### 数据库死锁是怎么造成的
#### MySQL如何处理死锁
#### InnoDB支持什么锁
### 5.4 引擎
#### MySQL引擎类别
### 5.5 SQL优化
#### limit为什么慢
#### 优化SQL `select * from t limit 1,100`
#### 数据库设计中遇到的问题
## 6 计算机网络
### 6.1 网络基础
#### `get`和`post`区别
#### `session`与`cookie`区别
#### 长连接和短链接
#### 从在浏览器输入网址到返回页面，经历了什么
### 6.2 TCP协议
#### TCP协议为什么是三次握手，两次为什么不可以
#### TCP链接通道里有什么，报文包含什么内容
#### TCP可靠传输（如果传输中丢失了报文如何处理）
#### TCP流量控制（如果发送方的速率高于接收方，如何避免接收缓存溢出）
#### TCP连接，其中一端断电会如何
## 7 操作系统
### 7.1 进程与线程
#### 线程进程的区别（资源、通信）
#### 线程有几种状态
### 7.2 死锁
#### 多线程死锁
#### 银行家算法
### 7.3 存储管理
#### 分页算法，FIFO、LRU
## 8 数据结构与算法
### 8.1 数据结构
#### 红黑树插入元素的过程（变色）
#### Java在哪里引入了红黑树
#### 为什么要引入红黑树
#### 红黑树的查找的时间复杂度
#### 队列和栈的区别
### 8.2 算法
#### 一句话描述动态规划，举一个生活中的例子
## 9 Linux
### 9.1 Linux命令
#### 使用 Linux命令找出日志文件中访问量最大的top10 IP地址
## 10 分布式中间件
Dubbo、Redis、Zookeeper、Kafka、Netty、MongoDB

## 11 项目
三个项目：   
一个侧重Java Web开发、设计与整体架构。   
一个侧重数据库优化。   
一个侧重产品创意团队协作   