[toc]

# 问题总结
## 1 Java基础
### 1.1 Java基础语法、语言特性
#### Java语言的特性，和其他语言的区别
1. 一次编写，处处运行。   
C语言和C++编写的代码编译成的机器码依赖于特定的运行环境，当运行环境改变或者更换CPU之后原来的代码需要作出很大的变动才能正常运行   
Java语言可以在不改变代码的情况下在不同的运行环境下正常运行，因为Java代码编译的时候并不是编译成机器代码，而是字节码这种中间代码，通过JVM把字节码边运行边解释成适合的机器码，保证了正常运行   
2. 安全性、多线程、动态等等优秀的特点
#### Java为什么可以跨平台
因为Java程序编译之后的代码不是能被硬件系统直接运行的代码，而是一种“中间码”——字节码。然后不同的硬件平台上安装有不同的Java虚拟机(JVM)，由JVM来把字节码再“翻译”成所对应的硬件平台能够执行的代码。因此对于Java编程者来说，不需要考虑硬件平台是什么，所以Java可以跨平台
### 1.2 Java关键字及常用方法
#### `final`关键字的作用
final可以用来修饰类，方法和变量（成员变量或局部变量）。   
1. 修饰类：final修饰类的时，表明该类不能被其他类所继承。注意：final类中所有的成员方法都会隐式的定义为final方法
2. 修饰方法：final修饰方法，表明该方法不能被重写。final修饰方法，表明该方法不能被重写。   
**注意**：类中所有private方法都是隐式的定义为final，为private方法添加final就毫无意义。
使用final方法的原因主要有两个：
    - 锁定方法，以防止继承类对其进行更改
    - 提升效率，在早期的java版本中，会将final方法转为内嵌调用，但若方法过于庞大，可能在性能上不会有多大提升。因此在最近版本中，不需要final方法进行这些优化了。
3. 修饰变量：
    - final修饰基本数据类型，表示该基本数据类型的值一旦在初始化后便不能发生变化；
    - final修饰引用类型，则在对其初始化之后便不能再让其指向其他对象了（不能再指向其他引用地址），但该引用所指向的对象的内容可以发生变化
    - final修饰成员变量，表示常量，只能被赋值一次，必须要显式初始化并且赋值后值不可改变。有两种初始化方式：在变量声明的时候初始化；在这个变量所在的类的所有的构造函数中对这个变量赋初值
    - final修饰函数的参数类型，说明该参数是只读型的。即你可以读取使用该参数，但是无法改变该参数的值
#### `final` `finally` `finalize`区别
1. final：可以用来修饰类，方法和变量（成员变量或局部变量）。
2. finally：`finally`作为异常处理的一部分，它只能用在`try...catch`语句中，并且附带一个语句块，表示这段语句最终（一般情况下）不管有没有抛出异常一定会被执行，经常被用在需要释放资源的情况下
    > 几种不会执行finally的情况：
    > ① 与`finally`对应的`try`语句块没有被执行
    > ② 在`try`语句块中执行了`System.exit(0)`语句，终止了Java虚拟机的运行
    > ③ 当一个线程在执行`try`语句块或者`catch`语句块时被打断（interrupted）或者被终止（killed）
    > ④ 在线程运行`try`语句块或者`catch`语句块时，突然死机或者断电
3. finalize：finalize()在java.lang.Object中定义，每一个对象都有这个方法。
    - 这个方法在GC启动，该对象被回收的时候被调用。
    - GC可以回收大部分的对象（凡是new出来的对象，GC都能回收），所以一般不需要程序员去实现finalize()。
    - 特殊情况下，需要程序员实现finalize()，比如：一个socket链接，在对象初始化时创建，整个生命周期内有效，那么就需要实现finalize()，关闭这个链接

#### `try...catch...finally`中`return`的执行结果
因为finally用法特殊，所以会撤销之前的return语句，继续执行最后的finally块中的代码。
```java
/**
 * try代码块已执行
 * try代码块已结束
 * finally代码块已执行
 * finally代码块已结束
 *
 * @return 3
 */
private int noErrorAndFinally() {
    try {
        System.out.println("try代码块已执行");
        System.out.println("try代码块已结束");
        return 1;
    } catch (Exception e) {
        System.out.println("catch代码块已执行");
        System.out.println("catch代码块已结束");
        return 2;
    } finally {
        System.out.println("finally代码块已执行");
        System.out.println("finally代码块已结束");
        return 3;
    }
}

/**
 * try代码块已执行
 * catch代码块已执行
 * catch代码块已结束
 * finally代码块已执行
 * finally代码块已结束
 *
 * @return 3
 */
private int hasErrorAndFinally() {
    try {
        System.out.println("try代码块已执行");
        int i = 1 / 0;
        System.out.println("i = " + i);
        System.out.println("try代码块已结束");
        return 1;
    } catch (Exception e) {
        System.out.println("catch代码块已执行");
        System.out.println("catch代码块已结束");
        return 2;
    } finally {
        System.out.println("finally代码块已执行");
        System.out.println("finally代码块已结束");
        return 3;
    }
}

/**
 * try代码块已执行
 * catch代码块已执行
 * catch代码块已结束
 *
 * @return 2
 */
private int hasErrorWithoutFinally() {
    try {
        System.out.println("try代码块已执行");
        int i = 1 / 0;
        System.out.println("i = " + i);
        System.out.println("try代码块已结束");
        return 1;
    } catch (Exception e) {
        System.out.println("catch代码块已执行");
        System.out.println("catch代码块已结束");
        return 2;
    }
}
```
#### `==`和`equals()`区别

#### `equal()`和`hashcode()`的联系和区别

#### `sleep()`和`wait()`的区别

#### `static`关键字，是否可以覆盖一个`static`方法

### 1.3 面向对象
#### Java多态有哪几种，如何实现（重写如何定位到对应方法）
#### 重载和重写的区别
#### 接口和抽象类的区别

### 1.4 常用类、接口及集合类
#### `int` `Integer`的区别
#### `String`，`StringBuffer`，`StringBuilder`区别，`String`是否线程安全为什么
#### `Array` `ArrayList`区别
#### `ArrayList` `LinkedList`区别
#### `Comparable`接口和`Comparator`接口实现比较
#### `CopyOnWriteArrayList`类
#### `HashMap` 中`put`方法过程
#### `HashMap`基于什么数据结构实现
#### `HashMap`如何处理hash冲突，扩容过程
#### 如何让`HashMap`线程安全
#### `HashMap` `CurrentHashMap` `LinkedHashMap` `HashTable`区别
#### `CurrentHashMap`实现线程安全的关键（JDK1.7 分段锁）

## 2 Java高级
### 2.1 I/O
#### BIO与NIO、AIO的区别

### 2.2 锁
#### Java中的锁有几种
#### 乐观锁和悲观锁
#### `Synchronized` `ReentrantLock`区别
#### `Synchronized`底层实现
#### `volatile`的作用及适用场景
#### CAS
#### CAS会产生什么问题

### 2.3 多线程与并发
#### 线程安全怎么理解
#### 实现多线程有几种实现方式
#### 实现`Runnable`接口要实现什么方法
#### 【自行整理】线程池`ThreadPoolExecutor`
#### `ThreadPoolExcutor()`创建线程池的主要参数
#### 线程池有什么用，为什么要使用线程池
#### `ThreadLocal`
### 2.4 设计模式   
#### 什么是动态代理和静态代理
#### 静态代理和动态代理的优缺点
#### 动态代理的实现
#### 单例模式
### 2.5 反射

## 3 JVM
周志明 深入理解Java虚拟机（重点看2、3、7、12、13这五章）
### 3.1 内存管理
#### JVM内存模型，垃圾回收回收的是哪部分
#### Java堆内存分代管理
#### 为什么需要两个Survivor区
#### Eden区和Survivor区的分配的大小比例，为什么
#### 堆的永久代和JVM方法栈有什么区别
#### 如何判断对象是否存活
#### JVM最大内存限制
### 3.3 垃圾回收算法
#### 垃圾回收算法
#### 垃圾回收是否有内存泄漏的风险
#### 强引用、弱引用、软引用、虚引用
### 3.3 类加载机制
#### 解释ClassLoader，类加载器有几种，类加载器加载顺序
#### 哪个框架破坏了双亲委派模式
#### 类的生命周期（类加载过程）
#### 编译生成的class存放在哪
## 4 框架
深入分析Java Web技术内幕（1、2、5-11章）
### 4.1 Spring、Spring Boot
#### 为什么要用Spring框架开发
#### IoC AOP 理解
#### Spring bean生命周期
### 4.2 Mybatis
#### mybatis $#的区别，为什么#可以防止注入
#### mybatis的resultmap如何映射，复杂的result类如何序列化
## 5 数据库
### 5.1 事务
#### 数据库事务如何实现
#### 事务的特性
#### 事务隔离级别和可能遇到的问题
### 5.2 索引
#### MySQL索引类别
#### 索引数据结构，为什么用B+树而不是而不是B树，两者有什么区别
#### 组合索引，查询`c>5 a=1`是否命中索引`ac`和`ca`
### 5.3 锁
#### 数据库死锁是怎么造成的
#### MySQL如何处理死锁
#### InnoDB支持什么锁
### 5.4 引擎
#### MySQL引擎类别
### 5.5 SQL优化
#### limit为什么慢
#### 优化SQL `select * from t limit 1,100`
#### 数据库设计中遇到的问题
## 6 计算机网络
### 6.1 网络基础
#### `get`和`post`区别
#### `session`与`cookie`区别
#### 长连接和短链接
#### 从在浏览器输入网址到返回页面，经历了什么
### 6.2 TCP协议
#### TCP协议为什么是三次握手，两次为什么不可以
#### TCP链接通道里有什么，报文包含什么内容
#### TCP可靠传输（如果传输中丢失了报文如何处理）
#### TCP流量控制（如果发送方的速率高于接收方，如何避免接收缓存溢出）
#### TCP连接，其中一端断电会如何
## 7 操作系统
### 7.1 进程与线程
#### 线程进程的区别（资源、通信）
#### 线程有几种状态
### 7.2 死锁
#### 多线程死锁
#### 银行家算法
### 7.3 存储管理
#### 分页算法，FIFO、LRU
## 8 数据结构与算法
### 8.1 数据结构
#### 红黑树插入元素的过程（变色）
#### Java在哪里引入了红黑树
#### 为什么要引入红黑树
#### 红黑树的查找的时间复杂度
#### 队列和栈的区别
### 8.2 算法
#### 一句话描述动态规划，举一个生活中的例子
## 9 Linux
### 9.1 Linux命令
#### 使用 Linux命令找出日志文件中访问量最大的top10 IP地址
## 10 分布式中间件
Dubbo、Redis、Zookeeper、Kafka、Netty、MongoDB

## 11 项目
三个项目：   
一个侧重Java Web开发、设计与整体架构。   
一个侧重数据库优化。   
一个侧重产品创意团队协作   