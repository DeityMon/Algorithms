[toc]

# 问题总结
## 1 Java基础
### 1.1 Java基础语法、语言特性
#### Java语言的特性，和其他语言的区别
1. 一次编写，处处运行。   
C语言和C++编写的代码编译成的机器码依赖于特定的运行环境，当运行环境改变或者更换CPU之后原来的代码需要作出很大的变动才能正常运行   
Java语言可以在不改变代码的情况下在不同的运行环境下正常运行，因为Java代码编译的时候并不是编译成机器代码，而是字节码这种中间代码，通过JVM把字节码边运行边解释成适合的机器码，保证了正常运行   
2. 安全性、多线程、动态等等优秀的特点

#### Java为什么可以跨平台
因为Java程序编译之后的代码不是能被硬件系统直接运行的代码，而是一种“中间码”——字节码。然后不同的硬件平台上安装有不同的Java虚拟机(JVM)，由JVM来把字节码再“翻译”成所对应的硬件平台能够执行的代码。因此对于Java编程者来说，不需要考虑硬件平台是什么，所以Java可以跨平台

### 1.2 Java关键字及常用方法
#### `final`关键字的作用
final可以用来修饰类，方法和变量（成员变量或局部变量）。   
1. 修饰类：final修饰类的时，表明该类不能被其他类所继承。注意：final类中所有的成员方法都会隐式的定义为final方法
2. 修饰方法：final修饰方法，表明该方法不能被重写。final修饰方法，表明该方法不能被重写。   
**注意**：类中所有private方法都是隐式的定义为final，为private方法添加final就毫无意义。
使用final方法的原因主要有两个：
    - 锁定方法，以防止继承类对其进行更改
    - 提升效率，在早期的java版本中，会将final方法转为内嵌调用，但若方法过于庞大，可能在性能上不会有多大提升。因此在最近版本中，不需要final方法进行这些优化了。
3. 修饰变量：
    - final修饰基本数据类型，表示该基本数据类型的值一旦在初始化后便不能发生变化；
    - final修饰引用类型，则在对其初始化之后便不能再让其指向其他对象了（不能再指向其他引用地址），但该引用所指向的对象的内容可以发生变化
    - final修饰成员变量，表示常量，只能被赋值一次，必须要显式初始化并且赋值后值不可改变。有两种初始化方式：在变量声明的时候初始化；在这个变量所在的类的所有的构造函数中对这个变量赋初值
    - final修饰函数的参数类型，说明该参数是只读型的。即你可以读取使用该参数，但是无法改变该参数的值

#### `final` `finally` `finalize`区别
1. final：可以用来修饰类，方法和变量（成员变量或局部变量）。
2. finally：`finally`作为异常处理的一部分，它只能用在`try...catch`语句中，并且附带一个语句块，表示这段语句最终（一般情况下）不管有没有抛出异常一定会被执行，经常被用在需要释放资源的情况下
    > 几种不会执行finally的情况：
    > ① 与`finally`对应的`try`语句块没有被执行
    > ② 在`try`语句块中执行了`System.exit(0)`语句，终止了Java虚拟机的运行
    > ③ 当一个线程在执行`try`语句块或者`catch`语句块时被打断（interrupted）或者被终止（killed）
    > ④ 在线程运行`try`语句块或者`catch`语句块时，突然死机或者断电
3. finalize：finalize()在java.lang.Object中定义，每一个对象都有这个方法。
    - 这个方法在GC启动，该对象被回收的时候被调用。
    - GC可以回收大部分的对象（凡是new出来的对象，GC都能回收），所以一般不需要程序员去实现finalize()。
    - 特殊情况下，需要程序员实现finalize()，比如：一个socket链接，在对象初始化时创建，整个生命周期内有效，那么就需要实现finalize()，关闭这个链接

#### `try...catch...finally`中`return`的执行结果
因为finally用法特殊，所以会撤销之前的return语句，继续执行最后的finally块中的代码。
```java
/**
 * try代码块已执行
 * try代码块已结束
 * finally代码块已执行
 * finally代码块已结束
 *
 * @return 3
 */
private int noErrorAndFinally() {
    try {
        System.out.println("try代码块已执行");
        System.out.println("try代码块已结束");
        return 1;
    } catch (Exception e) {
        System.out.println("catch代码块已执行");
        System.out.println("catch代码块已结束");
        return 2;
    } finally {
        System.out.println("finally代码块已执行");
        System.out.println("finally代码块已结束");
        return 3;
    }
}

/**
 * try代码块已执行
 * catch代码块已执行
 * catch代码块已结束
 * finally代码块已执行
 * finally代码块已结束
 *
 * @return 3
 */
private int hasErrorAndFinally() {
    try {
        System.out.println("try代码块已执行");
        int i = 1 / 0;
        System.out.println("i = " + i);
        System.out.println("try代码块已结束");
        return 1;
    } catch (Exception e) {
        System.out.println("catch代码块已执行");
        System.out.println("catch代码块已结束");
        return 2;
    } finally {
        System.out.println("finally代码块已执行");
        System.out.println("finally代码块已结束");
        return 3;
    }
}

/**
 * try代码块已执行
 * catch代码块已执行
 * catch代码块已结束
 *
 * @return 2
 */
private int hasErrorWithoutFinally() {
    try {
        System.out.println("try代码块已执行");
        int i = 1 / 0;
        System.out.println("i = " + i);
        System.out.println("try代码块已结束");
        return 1;
    } catch (Exception e) {
        System.out.println("catch代码块已执行");
        System.out.println("catch代码块已结束");
        return 2;
    }
}
```
#### `==`和`equals()`区别
1. 基本数据类型，也称原始数据类型。
`byte` `short` `char` `int` `long` `float` `double` `boolean`他们之间的比较，用`==`，比较的是他们的值
2. 复合数据类型（类）：
`==`：比较的是对象在内存中的存放地址；
基类Object中的基类中定义的`equals()`的方法，默认返回`==`运算的结果；
某些类中重写了`equals()`方法：`String` `Integer` `Double` `Date`等，返回值相等的结果

#### `equal()`和`hashCode()`的联系和区别
在Java中任何一个对象都具备`equals()`和`hashcode()`两个方法，因为他们是在`Object`类中定义的
1. `equals()`方法用来判断两个对象是否相同，如果相同则返回`true`，否则返回`false`
2. `hashcode()`方法返回`int`，在`Object`类中默认实现是：将该对象的内存地址转换成一个整数返回

其中两个重要规范
1. 【为什么重写`equals()`方法的同时要重写`hashCode()`方法】
如果`equals()`返回`true`，即两个对象相同，那么他们的`hashCode()`应该相等。因此，若重写`equals()`方法，有必要重写`hashCode()`方法，确保通过`equals()`方法判断结果为`true`的两个对象具备相等的`hashCode()`返回值。注意：这个只是规范，如果你非要写一个类让`equals()`返回`true`而`hashCode()`返回两个不相等的值，编译和运行都是不会报错的。不过这样违反了Java规范，程序也就埋下了BUG
2. 如果`equals()`返回`false`，即两个对象不相同，并不要求对这两个对象调用`hashCode()`方法得到两个不相同的数。说的简单点就是：如果两个对象不相同，他们的hashcode可能相同

【总结】根据这两个规范，可以得到如下推论： 
1. 如果两个对象`equals`，Java运行时环境会认为他们的`hashcode`一定相等【equals ＞ hashcode】
2. 如果两个对象不`equals`，他们的`hashcode`有可能相等
3. 如果两个对象`hashcode`相等，他们不一定`equals`【hashcode ≯ equals】
4. 如果两个对象`hashcode`不相等，他们一定不`equals` 

> `hashCode()`在哈希表中起作用，如`HashSet`、`HashMap`等。当我们向哈希表中添加对象`object`时，首先调用`hashCode()`方法计算`object`的哈希码，通过哈希码可以直接定位`object`在哈希表中的位置（一般是哈希码对哈希表大小取余）。如果该位置没有对象，可以直接将`object`插入该位置；如果该位置有对象，则调用`equals()`方法比较这些对象与`object`是否相等，如果相等，则不需要保存`object`；如果不相等，则将该对象加入到对应位置中

详细的解释：https://www.cnblogs.com/skywang12345/p/3324958.html

#### `static`关键字，是否可以覆盖一个`static`方法
static关键字表明一个成员变量或者是成员方法可以在没有所属的类实例变量的情况下被访问。被static标记的方法不能被覆盖，因为方法的覆盖是基于运行时动态绑定的，而static方法在编译时就已经和该类绑定了，也就是static标记的变量、方法都是随着类的加载而加载的，所以可以通过不创建对象实例就能访问该变量、方法；而不创建对象实例就访问非static变量、方法是不行的，因为此变量、方法还没有被创建。
- static标记的方法只能访问static变量或方法
- 非static标记的方法可以访问static或非static标记的变量或方法

#### `sleep()`和`wait()`的区别
1. `wait()`属于`Object`类，`sleep()`属于`Thread`类
2. 两者最主要的区别在于：`wait()`会释放对象锁而`sleep()`不会释放锁
    - 在调用`sleep()`方法的过程中，线程不会释放对象锁
    - 当调用`wait()`方法的时候，线程会放弃对象锁，进入等待此对象的等待池，只有针对此对象调用`notify()`或`notifyAll()`方法后本线程才进入对象锁池准备获取对象锁进入运行状态（线程不会自动苏醒，需要别的线程调用同一个对象上的`notify()`或者`notifyAll()`方法）。
    - `sleep()`方法执行完成后，线程会自动苏醒。
3. `wait()`需要在同步块中使用，`sleep()`可以在任何地方使用；
4. `sleep()`需要捕获异常，`wait()`不需要
5. `wait()`通常被用于线程间交互/通信，`sleep()`通常被用于暂停执行。

#### 为什么我们调用`start()`方法时会执行`run()`方法，为什么我们不能直接调用`run()`方法？
new一个Thread，线程进入了新建状态；调用`start()`方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。`start()`会执行线程的相应准备工作，然后自动执行`run()`方法的内容，这是真正的多线程工作。而直接执行`run()`方法，会把run方法当成一个main线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。

总结： 调用`start()`方法方可启动线程并使线程进入就绪状态，而`run()`方法只是thread的一个普通方法调用，还是在主线程里执行。

### 1.3 面向对象
#### Java多态有哪几种，如何实现（重写如何定位到对应方法）
1. 多态：对象的多种形态。（严格意义上的多态，只是继承！）
    -  引用多态：
        ① 父类的引用可以指向本类的对象
        ② 父类的引用可以指向子类的对象
    - 方法多态：
        ① 创建本类对象时，调用的方法为本类方法
        ② 创建子类对象时，调用的方法为子类重写的方法或者继承的方法
2. 动态绑定
    ```java
    Object o = new GeometricObject();   // 声明类型为Object，实际类型为GeometricObject
    System.out.println(o.toString());
    ```
    ⑴ 声明类型：一个变量必须被声明为某种类型，实例可以使用声明类型或它的子类型的构造方法创建
    ⑵ 实际类型：被变量引用的对象的实际类型
    
    代码中，`o`调用的到底是哪个`toString()`方法是由`o`的实际类型决定的，这称为动态绑定。动态绑定的工作机制：假设对象`o`是类`C1` `C2` ... `C(i)` ... `C(n)`的实例，其中`C(i-1)` 是`C(i)`的子类，`C(n)`是最通用的类、`C1`是最特殊的类。在Java中`C(n)`是`Object`类。如果对象`o`调用一个方法p，那么Java虚拟机会依次在`C1` `C2` ... `C(n)`中查找方法p的实现，直到找到为止。一旦找到这个实现，就停止查找然后调用这个第一次找到的实现
    
    匹配方法的签名和绑定方法的实现是两个独立的事情：
    ⑴ 引用变量的声明类型决定了编译时匹配哪个方法，编译器会在编译时，根据参数类型、参数个数、参数顺序找到匹配的方法（区分重载的方法）
    ⑵ 实际类型决定Java虚拟机在运行时动态绑定方法的实现，一个方法可能在几个子类中都被实现

广义上的多态：https://www.runoob.com/java/java-polymorphism.html

#### 重载和重写的区别
- 重载： 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。 　　
- 重写： 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为 private 则子类就不能重写该方法。

#### 接口和抽象类的区别
1. 接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。
2. 接口中除了static、final变量，不能有其他变量，而抽象类中则不一定。
3. 一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过extends关键字扩展多个接口。
4. 接口方法默认修饰符是public，抽象方法可以有public、protected和default这些修饰符（抽象方法就是为了被重写所以不能使用private关键字修饰！）。
5. 从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。

&nbsp; | 变量 | 构造方法 | 方法
:---:|:---:|:---:|:---:
抽象类 | 无限制 | 子类通过构造方法链调用构造方法，<br>抽象类不能用new操作符实例化<br> | 无限制
接口 | 所有的变量必须是<br>`public`或`static`或`final`<br> | 没有加构造方法。<br>接口不能用new操作符实例化<br> | 所有方法必须是公共的抽象示例方法

### 1.4 常用类、接口及集合类
#### `int` `Integer`的区别
1. `Integer`是`int`的包装类，`int`则是Java的一种基本数据类型
2. `Integer`变量必须实例化后才能使用，而int变量不需要 
3. `Integer`实际是对象的引用，当`new Integer()`时，实际上是生成一个指针指向此对象；而`int`则是直接存储数据值 
4. `Integer`的默认值是`null`，`int`的默认值是0

关于`Integer`和`int`进行比较的结果
1. 由于`Integer`变量实际上是对一个`Integer`对象的引用，所以两个通过`new`生成的`Integer`变量永远是不相等的（因为内存地址不同）

    ```java
    // result: false
    Integer a = new Integer(100);
    Integer b = new Integer(100);
    ```

2. 对于两个非`new`生成的`Integer`对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为`true`，如果两个变量的值不在此区间，则比较结果为`false`

    ```java
    // result: true
    Integer a = 100;
    Integer b = 100;
    
    // result: false
    a = 128;
    b = 128;
    ```
    java在编译`Integer i = 100;`时，会翻译成为`Integer i = Integer.valueOf(100);`，而Java API中对`Integer.valueOf()`定义如下：对于-128到127之间的数，会进行缓存

    ```java
    /**
     * This method will always cache values in the range -128 to 127,
     * inclusive, and may cache other values outside of this range.
     */
    public static Integer valueOf(int i) {
        if (i >= IntegerCache.low && i <= IntegerCache.high)
            return IntegerCache.cache[i + (-IntegerCache.low)];
        return new Integer(i);
    }
    ```
3. 非`new Integer()`变量和`new Integer()`生成的变量比较时，结果为false
    ⑴ 值在-128到127之间，非`new Integer()`变量在缓存中，`new Integer()`生成的变量为对象的引用，故不等
    
    ```java
    // result: false
    Integer a = 100;
    Integer b = new Integer(100);
    ```
    
    ⑵ 值不在-128到127之间，两种方法生成的均为对象的引用，故不等
    
    ```java
    // result: false
    Integer a = 258;
    Integer b = new Integer(258);
    ```
    
4. Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较）
    
    ```java
    // result: true
    Integer a = new Integer(100);
    int c = 100;
    ```

#### `String`，`StringBuffer`，`StringBuilder`区别，`String`为什么不可变，是否线程安全为什么
可变性
1. `String` 类中使用 `final` 关键字修饰字符数组来保存字符串，`private　final　char　value[]`，所以 `String` 对象是不可变的
2. `StringBuilder` 与 `StringBuffer` 都继承自 `AbstractStringBuilder` 类，在 `AbstractStringBuilder` 中也是使用字符数组保存字符串`char[] value`，但是没有用 `final` 关键字修饰，所以这两种对象都是可变的。
3. `StringBuilder` 与 `StringBuffer` 的构造方法都是调用父类构造方法也就是 `AbstractStringBuilder` 实现的。`AbstractStringBuilder` 源码如下：

```java
//AbstractStringBuilder.java
abstract class AbstractStringBuilder implements Appendable, CharSequence {
    char[] value;
    int count;
    AbstractStringBuilder() {
    }
    AbstractStringBuilder(int capacity) {
        value = new char[capacity];
    }
```

线程安全性
1. String 中的对象是不可变的，也就可以理解为常量，线程安全。
2. AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。
    ⑴ StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。
    ⑵ StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。　

性能
1. `String` `StringBuffer` `StringBuilder`都是`final`类，内部都是`char[]`实现，三者在执行速度方面：`StringBuilder` > `StringBuffer` > `String`
2. 每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。
3. StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 可以获得 10%~15% 左右的性能提升，但是要冒多线程不安全的风险。

使用总结
1. String，字符串常量，操作少量的数据用，类中定义的`char[]`是`final`的，不可变，因此是线程安全的
2. StringBuffer，字符串变量（线程安全），单线程操作字符串缓冲区下操作大量数据
3. StringBuilder，字符串变量（非线程安全），多线程操作字符串缓冲区下操作大量数据

> // 补充说明
> 为什么String要设计成不可变：https://www.cnblogs.com/sessionbest/articles/8688569.html
> 在java中，String被设计成final类，那为什么平时使用时，String的值可以被改变呢？
字符串常量池是java堆内存中一个特殊的存储区域，当我们建立一个String对象时，假设常量池不存在该字符串，则创建一个，若存在则直接引用已经存在的字符串。当我们对String对象值改变的时候，例如 String a="A"; a="B" 。a是String对象的一个引用（我们这里所说的String对象其实是指字符串常量），当a=“B”执行时，并不是原本String对象("A")发生改变，而是创建一个新的对象("B")，令a引用它。    
> 笔试题：https://www.cnblogs.com/AmyZheng/p/9415064.html

#### `Array` `ArrayList`区别
#### `ArrayList` `LinkedList`区别
#### `Comparable`接口和`Comparator`接口实现比较
#### `CopyOnWriteArrayList`类
#### `HashMap` 中`put`方法过程
#### `HashMap`基于什么数据结构实现
#### `HashMap`如何处理hash冲突，扩容过程
#### 如何让`HashMap`线程安全
#### `HashMap` `CurrentHashMap` `LinkedHashMap` `HashTable`区别
#### `CurrentHashMap`实现线程安全的关键（JDK1.7 分段锁）

## 2 Java高级
### 2.1 I/O
#### BIO与NIO、AIO的区别

### 2.2 锁
#### Java中的锁有几种
#### 乐观锁和悲观锁
#### `Synchronized` `ReentrantLock`区别
#### `Synchronized`底层实现
#### `volatile`的作用及适用场景
#### CAS
#### CAS会产生什么问题

### 2.3 多线程与并发
#### 线程安全怎么理解
#### 实现多线程有几种实现方式
#### 实现`Runnable`接口要实现什么方法
#### 【自行整理】线程池`ThreadPoolExecutor`
#### `ThreadPoolExcutor()`创建线程池的主要参数
#### 线程池有什么用，为什么要使用线程池
#### `ThreadLocal`
### 2.4 设计模式   
#### 什么是动态代理和静态代理
#### 静态代理和动态代理的优缺点
#### 动态代理的实现
#### 单例模式
### 2.5 反射

## 3 JVM
周志明 深入理解Java虚拟机（重点看2、3、7、12、13这五章）
### 3.1 内存管理
#### JVM内存模型，垃圾回收回收的是哪部分
#### Java堆内存分代管理
#### 为什么需要两个Survivor区
#### Eden区和Survivor区的分配的大小比例，为什么
#### 堆的永久代和JVM方法栈有什么区别
#### 如何判断对象是否存活
#### JVM最大内存限制
### 3.3 垃圾回收算法
#### 垃圾回收算法
#### 垃圾回收是否有内存泄漏的风险
#### 强引用、弱引用、软引用、虚引用
### 3.3 类加载机制
#### 解释ClassLoader，类加载器有几种，类加载器加载顺序
#### 哪个框架破坏了双亲委派模式
#### 类的生命周期（类加载过程）
#### 编译生成的class存放在哪
## 4 框架
深入分析Java Web技术内幕（1、2、5-11章）
### 4.1 Spring、Spring Boot
#### 为什么要用Spring框架开发
#### IoC AOP 理解
#### Spring bean生命周期
### 4.2 Mybatis
#### mybatis $#的区别，为什么#可以防止注入
#### mybatis的resultmap如何映射，复杂的result类如何序列化
## 5 数据库
### 5.1 事务
#### 数据库事务如何实现
#### 事务的特性
#### 事务隔离级别和可能遇到的问题
### 5.2 索引
#### MySQL索引类别
#### 索引数据结构，为什么用B+树而不是而不是B树，两者有什么区别
#### 组合索引，查询`c>5 a=1`是否命中索引`ac`和`ca`
### 5.3 锁
#### 数据库死锁是怎么造成的
#### MySQL如何处理死锁
#### InnoDB支持什么锁
### 5.4 引擎
#### MySQL引擎类别
### 5.5 SQL优化
#### limit为什么慢
#### 优化SQL `select * from t limit 1,100`
#### 数据库设计中遇到的问题
## 6 计算机网络
### 6.1 网络基础
#### `get`和`post`区别
#### `session`与`cookie`区别
#### 长连接和短链接
#### 从在浏览器输入网址到返回页面，经历了什么
### 6.2 TCP协议
#### TCP协议为什么是三次握手，两次为什么不可以
#### TCP链接通道里有什么，报文包含什么内容
#### TCP可靠传输（如果传输中丢失了报文如何处理）
#### TCP流量控制（如果发送方的速率高于接收方，如何避免接收缓存溢出）
#### TCP连接，其中一端断电会如何
## 7 操作系统
### 7.1 进程与线程
#### 线程进程的区别（资源、通信）
#### 线程有几种状态
### 7.2 死锁
#### 多线程死锁
#### 银行家算法
### 7.3 存储管理
#### 分页算法，FIFO、LRU
## 8 数据结构与算法
### 8.1 数据结构
#### 红黑树插入元素的过程（变色）
#### Java在哪里引入了红黑树
#### 为什么要引入红黑树
#### 红黑树的查找的时间复杂度
#### 队列和栈的区别
### 8.2 算法
#### 一句话描述动态规划，举一个生活中的例子
## 9 Linux
### 9.1 Linux命令
#### 使用 Linux命令找出日志文件中访问量最大的top10 IP地址
## 10 分布式中间件
Dubbo、Redis、Zookeeper、Kafka、Netty、MongoDB

## 11 项目
三个项目：   
一个侧重Java Web开发、设计与整体架构。   
一个侧重数据库优化。   
一个侧重产品创意团队协作   